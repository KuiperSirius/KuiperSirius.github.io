<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>暮城雨烟</title>
  
  <subtitle>The Sound of Silence</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.kixcs.com/"/>
  <updated>2020-03-06T14:45:54.396Z</updated>
  <id>https://blog.kixcs.com/</id>
  
  <author>
    <name>夜阑听烟雨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hitokoto一言API及微软Bing每日壁纸API的实现</title>
    <link href="https://blog.kixcs.com/archives/3869/"/>
    <id>https://blog.kixcs.com/archives/3869/</id>
    <published>2020-03-06T14:22:55.000Z</published>
    <updated>2020-03-06T14:45:54.396Z</updated>
    
    <content type="html"><![CDATA[<p class="description">一言网(Hitokoto.cn)创立于2016年，隶属于萌创Team，目前网站主要提供一句话服务。“动漫也好、小说也好、网络也好，不论在哪里，我们总会看到有那么一两个句子能穿透你的心。我们把这些句子汇聚起来，形成一言网络，以传递更多的感动。如果可以，我们希望我们没有停止服务的那一天。”简单来说，一言指的就是一句话，可以是动漫中的台词，也可以是网络上的各种小段子。或是感动，或是开心，有或是单纯的回忆，与大家分享，这就是一言存在的目的。</p><a id="more"></a><h4 id="Hitokoto一言API"><a href="#Hitokoto一言API" class="headerlink" title="Hitokoto一言API"></a>Hitokoto一言API</h4><p>下面简单介绍本站部署Hitokoto一言API的过程：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//Ps：喜欢使用官方接口也可以前往官方的API介绍地址参考部署：https://hitokoto.cn/api</span></span><br><span class="line"><span class="comment">//获取句子文件的绝对路径</span></span><br><span class="line"><span class="comment">//如果你介意别人可能会拖走这个文本，可以将文件名自定义一下，或者通过配置文件权限，禁止Nginx拉取也行。</span></span><br><span class="line">$path = dirname(<span class="keyword">__FILE__</span>);</span><br><span class="line">$file = file($path.<span class="string">"/hitokoto.txt"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//随机读取一行</span></span><br><span class="line">$arr  = mt_rand( <span class="number">0</span>, count( $file ) - <span class="number">1</span> );</span><br><span class="line">$content  = trim($file[$arr]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//编码判断，用于输出相应的响应头部编码</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'charset'</span>]) &amp;&amp; !<span class="keyword">empty</span>($_GET[<span class="string">'charset'</span>])) &#123;</span><br><span class="line">    $charset = $_GET[<span class="string">'charset'</span>];</span><br><span class="line">    <span class="keyword">if</span> (strcasecmp($charset,<span class="string">"gbk"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">        $content = mb_convert_encoding($content,<span class="string">'gbk'</span>, <span class="string">'utf-8'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $charset = <span class="string">'utf-8'</span>;</span><br><span class="line">&#125;</span><br><span class="line">header(<span class="string">"Content-Type: text/html; charset=$charset"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//格式化判断，输出js或纯文本</span></span><br><span class="line"><span class="keyword">if</span> ($_GET[<span class="string">'format'</span>] === <span class="string">'js'</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"function hitokoto()&#123;document.write('"</span> . $content .<span class="string">"');&#125;"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> $content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**以上代码保存为index.php，然后上传到网站根目录下的hitokoto文件夹（这个自己随机定义）即可。</span></span><br><span class="line"><span class="comment">*把hitokoto.txt上传至网站目录，并写入相应内容。</span></span><br><span class="line"><span class="comment">*尽管如此，倘若有高并发请求的业务需求，推荐使用MySQL来进行内容管理。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>现在，通过域名/路径就可以看到返回的结果了。[<span class="exturl" data-url="aHR0cHM6Ly9teWRvbWFpbi5jb20vaGl0b2tvdG9d" title="https://mydomain.com/hitokoto]">https://mydomain.com/hitokoto]<i class="fa fa-external-link"></i></span><br>部署方法如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"https://你的域名/hitokoto/?format=js&amp;charset=utf-8"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;div id="hitokoto"&gt;&lt;script&gt;hitokoto()&lt;/</span>script&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><h4 id="微软Bing每日壁纸API"><a href="#微软Bing每日壁纸API" class="headerlink" title="微软Bing每日壁纸API"></a>微软Bing每日壁纸API</h4><p>必应美图官方的 API 接口如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;国内版</span><br><span class="line">https:&#x2F;&#x2F;cn.bing.com&#x2F;HPImageArchive.aspx?idx&#x3D;0&amp;n&#x3D;1</span><br><span class="line">https:&#x2F;&#x2F;cn.bing.com&#x2F;HPImageArchive.aspx?format&#x3D;js&amp;idx&#x3D;0&amp;n&#x3D;1&amp;mkt&#x3D;zh-CN</span><br><span class="line">&#x2F;&#x2F;国际版[From: https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;10639914&#x2F;is-there-a-way-to-get-bings-photo-of-the-day]</span><br><span class="line">https:&#x2F;&#x2F;www.bing.com&#x2F;HPImageArchive.aspx?format&#x3D;js&amp;idx&#x3D;0&amp;n&#x3D;1</span><br><span class="line">XML: https:&#x2F;&#x2F;www.bing.com&#x2F;HPImageArchive.aspx?format&#x3D;xml&amp;idx&#x3D;0&amp;n&#x3D;1&amp;mkt&#x3D;en-US</span><br><span class="line">JSON: https:&#x2F;&#x2F;www.bing.com&#x2F;HPImageArchive.aspx?format&#x3D;js&amp;idx&#x3D;0&amp;n&#x3D;1&amp;mkt&#x3D;en-US</span><br><span class="line">RSS: https:&#x2F;&#x2F;www.bing.com&#x2F;HPImageArchive.aspx?format&#x3D;rss&amp;idx&#x3D;0&amp;n&#x3D;1&amp;mkt&#x3D;en-US</span><br></pre></td></tr></table></figure><p>其中参数说明:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">参数名称                值含义</span><br><span class="line"></span><br><span class="line">format(非必需)      返回数据格式，未定义则默认返回XML格式</span><br><span class="line">                       •js(常使用，返回JSON格式)</span><br><span class="line">                       •xml(返回XML格式)</span><br><span class="line"></span><br><span class="line">idx(非必需)         请求图片截止天数</span><br><span class="line">                       •0(今天) </span><br><span class="line">                       •-1(截止到明天，预准备) </span><br><span class="line">                       •1(截止至昨天，最多支持获取7天前的图片) </span><br><span class="line"></span><br><span class="line">n(必需)             1-8返回请求数量，目前最多一次获取8张</span><br><span class="line"></span><br><span class="line">mkt(非必需)         国家&#x2F;地区代码</span><br><span class="line">                       •zh-CN(中国) </span><br><span class="line">                       •en-US(美国)</span><br></pre></td></tr></table></figure><p>根据官方API返回的内容，对域名和url字段进行拼接即可得到图片地址。该.php文件内容如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Template Name: API-BingPicture</span></span><br><span class="line"><span class="comment"> description: template for TOMORROW 星辰</span></span><br><span class="line"><span class="comment"> https://www.tomorrow.wiki/archives/453</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span>(file_exists(<span class="string">"bingDaily.jpg"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    $time = time();</span><br><span class="line">         </span><br><span class="line">    <span class="comment">//文件修改时间和现在时间相差 24 小时以下的话，直接导向静态文件 jpg，否则重新生成 jpg</span></span><br><span class="line">    <span class="keyword">if</span>($time - filemtime(<span class="string">"bingDaily.jpg"</span>) &lt; <span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        header(<span class="string">"Location:./bingDaily.jpg"</span>);</span><br><span class="line">      <span class="keyword">exit</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$str=file_get_contents(<span class="string">'https://cn.bing.com/HPImageArchive.aspx?idx=0&amp;n=1'</span>);</span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">"/(.+?)&lt;\/url&gt;/ies"</span>, $str, $matches)) </span><br><span class="line">&#123;</span><br><span class="line">$imgurl=<span class="string">'https://cn.bing.com'</span>.$matches[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">ob_end_clean();</span><br><span class="line">ob_start(); </span><br><span class="line">header(<span class="string">'Content-Type: image/JPEG'</span>);</span><br><span class="line">@readfile($imgurl);</span><br><span class="line">$temp =  ob_get_contents(); </span><br><span class="line">@ob_flush();</span><br><span class="line">$fp = fopen(<span class="string">"bingDaily.jpg"</span>,<span class="string">'w'</span>); </span><br><span class="line">fwrite($fp,$temp) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">'写文件错误'</span>); </span><br><span class="line">header(<span class="string">"Location:./bingDaily.jpg"</span>);</span><br><span class="line"><span class="keyword">exit</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>最后，附上两条集成的API(对API进行外部资源引用注意Nginx的跨域配置问题):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;已拦截跨源请求：同源策略禁止读取位于 https:&#x2F;&#x2F;api.kixcs.com&#x2F;hitokoto&#x2F;?encode&#x3D;json 的远程资源。</span><br><span class="line">（原因：CORS 头缺少 &#39;Access-Control-Allow-Origin&#39;）。</span><br><span class="line">&#x2F;&#x2F;.php文件中，开启跨域Ajax支持。</span><br><span class="line">header(&#39;Access-Control-Allow-Origin:*&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或者Nginx配置</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line">            # 允许 所有头部 所有域 所有方法</span><br><span class="line">            add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;</span><br><span class="line">            add_header &#39;Access-Control-Allow-Headers&#39; &#39;*&#39;;</span><br><span class="line">            add_header &#39;Access-Control-Allow-Methods&#39; &#39;*&#39;;</span><br><span class="line">            # OPTIONS 直接返回204</span><br><span class="line">            if ($request_method &#x3D; &#39;OPTIONS&#39;) &#123;</span><br><span class="line">                return 200;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;api.kixcs.com&#x2F;hitokoto&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;api.kixcs.com&#x2F;bing</span><br></pre></td></tr></table></figure><h4 id="备选方法"><a href="#备选方法" class="headerlink" title="备选方法"></a>备选方法</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">define(<span class="string">'IN_HITOKOTO'</span>, <span class="keyword">TRUE</span>);</span><br><span class="line">header(<span class="string">'Content-Type: text/html; charset=UTF-8'</span>);</span><br><span class="line"><span class="comment">//开启跨域Ajax支持</span></span><br><span class="line">header(<span class="string">'Access-Control-Allow-Origin:*'</span>);</span><br><span class="line"><span class="comment">//初始化资源文件</span></span><br><span class="line">$array = file(<span class="string">'./content.php'</span>);</span><br><span class="line"><span class="comment">//参数传递</span></span><br><span class="line">$encode = $_GET[<span class="string">'encode'</span>];</span><br><span class="line">$id = $_GET[<span class="string">'id'</span>];</span><br><span class="line"><span class="comment">//一言开始行数（0为验证行）</span></span><br><span class="line">$id_min = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//一言结束行数</span></span><br><span class="line">$id_max = <span class="number">3388</span>;</span><br><span class="line"><span class="comment">//随机 - 判断数字</span></span><br><span class="line"><span class="keyword">if</span> (!$id == <span class="keyword">NULL</span> &amp;&amp; is_numeric($id))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断大小</span></span><br><span class="line">    <span class="keyword">if</span> ($id &gt;= $id_min &amp;&amp; $id &lt;= $id_max)</span><br><span class="line">    &#123;</span><br><span class="line">        $number = $id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        $number = rand($id_min,$id_max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    $number = rand($id_min,$id_max);</span><br><span class="line">&#125;</span><br><span class="line">$string = $array[$number];</span><br><span class="line"><span class="comment">//判断输出类型</span></span><br><span class="line"><span class="keyword">if</span> ($encode == <span class="string">'javascript'</span> || $encode == <span class="string">'js'</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'function getHitokoto()&#123;document.write("'</span>,trim($string),<span class="string">'");&#125;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> trim($string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用UTF-8-BOM编码（content.php），注意一言文本行数要与index.php中的$id_max匹配。</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">if</span>(!defined(<span class="string">'IN_HITOKOTO'</span>))&#123;<span class="keyword">echo</span> <span class="string">"Access Denied."</span>;<span class="keyword">exit</span>();&#125;;<span class="meta">?&gt;</span></span><br><span class="line">你们媒体千万要注意啊，不要“见着风，是得雨”啊。</span><br><span class="line">接到这些消息，你媒体本身也要判断，明白意思吗？</span><br><span class="line">假使这些完全……无中生有的东西，你再帮他说一遍，你等于……你也等于……你也有责任吧？</span><br><span class="line">..........</span><br><span class="line">..........</span><br></pre></td></tr></table></figure><p>请求方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$id</span><br><span class="line">Normal: Random ID</span><br><span class="line">Option: $id_min ~ $id_max</span><br><span class="line">Request URL: https:&#x2F;&#x2F;api.kixcs.com&#x2F;hitokoto&#x2F;?id&#x3D;2</span><br><span class="line">Request Method: GET</span><br><span class="line">Respond:接到这些消息，你媒体本身也要判断，明白意思吗？</span><br><span class="line">(The id of this sentence is 2.)</span><br><span class="line"></span><br><span class="line">$encode</span><br><span class="line">Normal: text</span><br><span class="line">Option: javascript or js</span><br><span class="line">Request URL: https:&#x2F;&#x2F;api.kixcs.com&#x2F;hitokoto&#x2F;?encode&#x3D;js</span><br><span class="line">Request Method: GET</span><br><span class="line">Respond:function getHitokoto()&#123;document.write(&quot;我没有说要钦定，没有任何这个意思。&quot;);&#125;</span><br></pre></td></tr></table></figure><p>前端页面中，使用如下代码进行调用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"https://api.kixcs.com/hitokoto/?encode=javascript"</span>&gt;&lt;<span class="regexp">/script&gt; </span></span><br><span class="line"><span class="regexp">&lt;span class="getHitokoto"&gt;&lt;script&gt;getHitokoto()&lt;/</span>script&gt;&lt;<span class="regexp">/span&gt;</span></span><br></pre></td></tr></table></figure><p>注意，倘若控制台出现:”Refused to execute script from because its MIME type (‘text/html’) is not executable, and strict MIME type checking is enabled.”类似错误，JS的MIME的type=”text/javascript”配置正确，则有可能是CDN引发的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//github.com/rails/webpacker/issues/1651</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;
一言网(Hitokoto.cn)创立于2016年，隶属于萌创Team，目前网站主要提供一句话服务。“动漫也好、小说也好、网络也好，不论在哪里，我们总会看到有那么一两个句子能穿透你的心。我们把这些句子汇聚起来，形成一言网络，以传递更多的感动。如果可以，我们希望我们没有停止服务的那一天。”
简单来说，一言指的就是一句话，可以是动漫中的台词，也可以是网络上的各种小段子。或是感动，或是开心，有或是单纯的回忆，与大家分享，这就是一言存在的目的。
&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计" scheme="https://blog.kixcs.com/categories/design/"/>
    
    
      <category term="API" scheme="https://blog.kixcs.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>一些前端JS CDN开源库的国内镜像及Hexo相关配置</title>
    <link href="https://blog.kixcs.com/archives/9e1/"/>
    <id>https://blog.kixcs.com/archives/9e1/</id>
    <published>2020-03-03T13:56:39.000Z</published>
    <updated>2020-03-22T16:09:35.921Z</updated>
    
    <content type="html"><![CDATA[<p>由于国内外互联网的环境差异，许多开源的JS库均采用海外CDN托管的方式，致使无法保证大陆的访问体验。因此特此分享一下公益项目，托管了CDNJS的所有开源JS库以及反代了Google Fonts、Ajax和Gravatar，并且全部支持http和https。该公益库每天定时同步CDN，抑或是采用Nginx的反向代理配合关键词替换的方式实现。倘若觉得麻烦，可以通过jsdelivr配合GitHub来保证境内的网络响应速度，前者貌似是唯一一家在国内取得ICP执照的公共CDN，在国内合作伙伴为网宿科技。</p><p class="description"></p><a id="more"></a><h4 id="CDNJS-开源JS库"><a href="#CDNJS-开源JS库" class="headerlink" title="CDNJS 开源JS库"></a>CDNJS 开源JS库</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有的JS/CSS库如下链接所示:</span></span><br><span class="line">https:<span class="comment">//cdnjs.loli.net/ajax/libs/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果使用 cdnjs.com 只需要替换 cdnjs.cloudflare.com 为 cdnjs.loli.net 即可，如</span></span><br><span class="line">&lt;script src=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="https:/</span><span class="regexp">/cdnjs.loli.net/</span>ajax/libs/jquery/<span class="number">3.2</span><span class="number">.1</span>/jquery.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//CDNJS的API开发文档请详见 https://cdnjs.com/api</span></span><br></pre></td></tr></table></figure><h4 id="Google-Fonts"><a href="#Google-Fonts" class="headerlink" title="Google Fonts"></a>Google Fonts</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只需要替换 fonts.googleapis.com 为 fonts.loli.net 即可</span></span><br><span class="line">&lt;link href=<span class="string">'https://fonts.googleapis.com/css?family=Open+Sans'</span> rel=<span class="string">'stylesheet'</span>&gt;</span><br><span class="line">&lt;link href=<span class="string">'https://fonts.loli.net/css?family=Open+Sans'</span> rel=<span class="string">'stylesheet'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果需要 Material icons ，可进行如下替换:</span></span><br><span class="line"><span class="comment">//https://material.io/icons/</span></span><br><span class="line">&lt;link href=<span class="string">'https://fonts.googleapis.com/icon?family=Material+Icons'</span> rel=<span class="string">'stylesheet'</span>&gt;</span><br><span class="line">&lt;link href=<span class="string">'https://fonts.loli.net/icon?family=Material+Icons'</span> rel=<span class="string">'stylesheet'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果需要 Early Access，可进行如下替换:</span></span><br><span class="line"><span class="comment">//https://fonts.google.com/earlyaccess</span></span><br><span class="line">@<span class="keyword">import</span> url(https:<span class="comment">//fonts.googleapis.com/earlyaccess/notosanskannada.css); </span></span><br><span class="line">@<span class="keyword">import</span> url(https:<span class="comment">//fonts.loli.net/earlyaccess/notosanskannada.css); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果需要下载单个字体，只需要把 fonts.gstatic.com 替换成 gstatic.loli.net 或 themes.googleusercontent.com 替换成 themes.loli.net 即可</span></span><br><span class="line">https:<span class="comment">//fonts.gstatic.com/s/opensans/v14/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2</span></span><br><span class="line">https:<span class="comment">//gstatic.loli.net/s/opensans/v14/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2</span></span><br><span class="line"></span><br><span class="line">https:<span class="comment">//themes.googleusercontent.com/static/fonts/anonymouspro/v3/Zhfjj_gat3waL4JSju74E-V_5zh5b-_HiooIRUBwn1A.ttf</span></span><br><span class="line">https:<span class="comment">//themes.loli.net/static/fonts/anonymouspro/v3/Zhfjj_gat3waL4JSju74E-V_5zh5b-_HiooIRUBwn1A.ttf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Google Fonts的API文档请详见: https://developers.google.com/fonts/docs/getting_started</span></span><br></pre></td></tr></table></figure><h4 id="Google前端公共库"><a href="#Google前端公共库" class="headerlink" title="Google前端公共库"></a>Google前端公共库</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接替换 ajax.googleapis.com 为 ajax.loli.net 即可，如</span></span><br><span class="line">&lt;script type=<span class="string">'text/javascript'</span> src=<span class="string">'https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js'</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type='text/</span>javascript<span class="string">' src='</span>https:<span class="comment">//ajax.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js'&gt;&lt;/script&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Google前端库API开发文档详见: https://developers.google.com/speed/libraries/</span></span><br></pre></td></tr></table></figure><h4 id="Gravatar-头像"><a href="#Gravatar-头像" class="headerlink" title="Gravatar 头像"></a>Gravatar 头像</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接替换 *.gravatar.com 为 gravatar.loli.net 即可</span></span><br><span class="line">https:<span class="comment">//secure.gravatar.com/avatar/233</span></span><br><span class="line">https:<span class="comment">//gravatar.loli.net/avatar/233</span></span><br></pre></td></tr></table></figure><p>鸣谢<span class="exturl" data-url="aHR0cHM6Ly9zYi5zYi9ibG9nL2Nzcy1jZG4v" title="https://sb.sb/blog/css-cdn/">烧饼博客<i class="fa fa-external-link"></i></span>的无私分享和长久以来的维护工作，再次感谢~</p><h4 id="Hexo修改字体"><a href="#Hexo修改字体" class="headerlink" title="Hexo修改字体"></a>Hexo修改字体</h4><h5 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改 _config.yml"></a>修改 _config.yml</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件路径：~/blog/themes/next/_config.yml，将下列代码中的部分替换即可。</span></span><br><span class="line">font:</span><br><span class="line">- enable: <span class="literal">false</span></span><br><span class="line">+ enable: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  # Uri of fonts host. E.g. //fonts.googleapis.com (Default).</span><br><span class="line">+ host: https:<span class="comment">//fonts.loli.net</span></span><br><span class="line"></span><br><span class="line">  # Font options:</span><br><span class="line">  # `external: true` will load this font family from `host` above.</span><br><span class="line">  # `family: Times New Roman`. Without any quotes.</span><br><span class="line">  # `size: xx`. Use `px` as unit.</span><br><span class="line"></span><br><span class="line">  # Global font settings used for all elements in &lt;body&gt;.</span><br><span class="line">  global:</span><br><span class="line">    external: <span class="literal">true</span></span><br><span class="line">+   family: Noto Serif SC</span><br><span class="line">    size:</span><br></pre></td></tr></table></figure><h5 id="修改-base-styl"><a href="#修改-base-styl" class="headerlink" title="修改 base.styl"></a>修改 base.styl</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件路径：~/blog/themes/next/source/css/_variables/base.styl</span></span><br><span class="line">-$font-family-monospace    = consolas, Menlo, $font-family-chinese, monospace</span><br><span class="line">+$font-family-monospace    = consolas, Menlo, $font-family-base, monospace</span><br><span class="line">-$font-family-monospace    = get_font_family(<span class="string">'codes'</span>), consolas, Menlo, $font-family-chinese, monospace <span class="keyword">if</span> get_font_family(<span class="string">'codes'</span>)</span><br><span class="line">+$font-family-monospace    = get_font_family(<span class="string">'codes'</span>), consolas, Menlo, $font-family-base, monospace <span class="keyword">if</span> get_font_family(<span class="string">'codes'</span>)</span><br></pre></td></tr></table></figure><h5 id="设置文字大小"><a href="#设置文字大小" class="headerlink" title="设置文字大小"></a>设置文字大小</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件路径：~/blog/themes/next/source/css/_variables/base.styl</span></span><br><span class="line"><span class="comment">//_config.yml中设置size属性为16px可能效果不理想</span></span><br><span class="line">$font-size-base     = <span class="number">16</span>px</span><br></pre></td></tr></table></figure><h5 id="更改字体颜色"><a href="#更改字体颜色" class="headerlink" title="更改字体颜色"></a>更改字体颜色</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件路径：~/blog/themes/next/source/css/_custom/custom.styl</span></span><br><span class="line"><span class="comment">//新版本NexT配置文件路径为: Hexo/MyBlog/source/_data/styles.styl，须在配置文件中启用。</span></span><br><span class="line"><span class="comment">//修改字体颜色</span></span><br><span class="line">body &#123;</span><br><span class="line">    color: #000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GitHub代理设置"><a href="#GitHub代理设置" class="headerlink" title="GitHub代理设置"></a>GitHub代理设置</h4><h5 id="Global-Proxy"><a href="#Global-Proxy" class="headerlink" title="Global Proxy"></a>Global Proxy</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http:<span class="comment">//127.0.0.1:2080</span></span><br><span class="line">git config --global https.proxy https:<span class="comment">//127.0.0.1:2080</span></span><br></pre></td></tr></table></figure><h5 id="GitHub-Proxy"><a href="#GitHub-Proxy" class="headerlink" title="GitHub Proxy"></a>GitHub Proxy</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*可以做到国内外仓库的Git分流</span></span><br><span class="line"><span class="comment">*注:无论是Git的全局代理还是GitHub分流代理，都是基于HTTPS协议的。</span></span><br><span class="line"><span class="comment">* 仅对 git clone https://github.com/[ID]/[repositories].git生效</span></span><br><span class="line"><span class="comment">* 对于SSH协议依旧无效，如: git clone git@github.com:[ID]/[repositories].git </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">git config --global http.https:<span class="comment">//github.com.proxy https://127.0.0.1:2080</span></span><br><span class="line">git config --global https.https:<span class="comment">//github.com.proxy https://127.0.0.1:2080</span></span><br></pre></td></tr></table></figure><h5 id="Sock5-Proxy"><a href="#Sock5-Proxy" class="headerlink" title="Sock5 Proxy"></a>Sock5 Proxy</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.https:<span class="comment">//github.com.proxy socks5://127.0.0.1:2080</span></span><br><span class="line">git config --global https.https:<span class="comment">//github.com.proxy socks5://127.0.0.1:2080</span></span><br></pre></td></tr></table></figure><h5 id="Cancel-Proxy"><a href="#Cancel-Proxy" class="headerlink" title="Cancel Proxy"></a>Cancel Proxy</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><h5 id="Proxy-Info"><a href="#Proxy-Info" class="headerlink" title="Proxy Info"></a>Proxy Info</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global -l</span><br></pre></td></tr></table></figure><h4 id="GitHub-GPG设置"><a href="#GitHub-GPG设置" class="headerlink" title="GitHub GPG设置"></a>GitHub GPG设置</h4><p>首先，需要让Git知道签名所用的GPG密钥ID：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.signingkey &#123;key_id&#125;</span><br></pre></td></tr></table></figure><p>然后，在每次commit的时候，加上-S参数，表示这次提交需要用GPG密钥进行签名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -S -m <span class="string">"..."</span></span><br></pre></td></tr></table></figure><p>如果觉得每次都需要手动加上-S有些麻烦，可以设置Git为每次commit自动要求签名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global commit.gpgsign <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>但不论是否需要手动加上-S，commit时皆会弹出对话框，需要输入该密钥的密码，以确保是密钥拥有者本人操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于国内外互联网的环境差异，许多开源的JS库均采用海外CDN托管的方式，致使无法保证大陆的访问体验。因此特此分享一下公益项目，托管了CDNJS的所有开源JS库以及反代了Google Fonts、Ajax和Gravatar，并且全部支持http和https。该公益库每天定时同步CDN，抑或是采用Nginx的反向代理配合关键词替换的方式实现。倘若觉得麻烦，可以通过jsdelivr配合GitHub来保证境内的网络响应速度，前者貌似是唯一一家在国内取得ICP执照的公共CDN，在国内合作伙伴为网宿科技。&lt;/p&gt;
&lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计" scheme="https://blog.kixcs.com/categories/design/"/>
    
    
      <category term="CDN" scheme="https://blog.kixcs.com/tags/CDN/"/>
    
      <category term="Fonts" scheme="https://blog.kixcs.com/tags/Fonts/"/>
    
  </entry>
  
  <entry>
    <title>利用GitHub仓库分支备份Hexo博客源文件</title>
    <link href="https://blog.kixcs.com/archives/a2af/"/>
    <id>https://blog.kixcs.com/archives/a2af/</id>
    <published>2020-03-01T14:29:13.000Z</published>
    <updated>2020-03-04T14:36:36.163Z</updated>
    
    <content type="html"><![CDATA[<p class="description">Hexo静态部署到托管平台很方便，考虑到异地更新并提交Hexo博客内容的需求，可以考虑通过仓库的多分支来解决。hexo部署命令生成的静态网址默认是保存在github_name/github_name.github.io的master分支上，因此，可以在原有的基础上增加一个hexo_source分支保存网址原始数据，并将这个分支设置为默认分支。如此以来，系统环境配置完成后，每次恢复和迁移文件时候只需要git clone即可获取迁移的文件了。 </p><a id="more"></a><h4 id="更改仓库的默认分支"><a href="#更改仓库的默认分支" class="headerlink" title="更改仓库的默认分支"></a>更改仓库的默认分支</h4><p>GitHub上的仓库初始都会有个master分支，也就是默认分支。对于一个仓库project_name，当我们通过git clone <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0t1aXBlclNpcml1cy9wcm9qZWN0X25hbWUuZ2l0" title="https://github.com/KuiperSirius/project_name.git">https://github.com/KuiperSirius/project_name.git<i class="fa fa-external-link"></i></span> 下载代码时，实际拉取的是默认分支master对应的代码。而使用hexo写博客时，通常是与md源文件打交道，对于deploy生成的master分支代码并不需要我们关注，因此可将仓库的默认分支改为保存源码的source分支，这样通过git clone拉取的就是source分支代码了。</p><h4 id="Git准备工作"><a href="#Git准备工作" class="headerlink" title="Git准备工作"></a>Git准备工作</h4><p>通常情况下，在原Hexo托管的仓库上建立分支，并确保原仓库内已有master分支(该分支通常被用于GitHub Pages的默认绑定)。进入本地博客根目录，进行如下操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">git初始化</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta">#</span><span class="bash">初始化完成之后，添加修改的文件，由于Hexo就自带了.gitignore文件，即需要忽略的文件，add 全部文件。</span></span><br><span class="line">git add .</span><br><span class="line"><span class="meta">#</span><span class="bash">然后commit提交</span></span><br><span class="line">git commit -m "commit first time|描述内容"</span><br><span class="line"><span class="meta">#</span><span class="bash">提交成功之后，接下来需要push到github项目地址，需要先把Hexo源文件映射到远程resposity上。</span></span><br><span class="line">git remote add origin https://github.com/your-name/your-name.github.io.git</span><br></pre></td></tr></table></figure><p>.gitignore文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure><h4 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h4><p>接下来的工作即为将Hexo源文件push上去，其中仓库的master上是Hexo生成博客网页的代码，而Hexo源文件是要push到一个分支上面的，进行如下操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">所以接下来先要在repo上新建一个叫<span class="built_in">source</span>的分支</span></span><br><span class="line">git branch source</span><br><span class="line"><span class="meta">#</span><span class="bash">查看本地分支，并且切换到<span class="built_in">source</span>分支。</span></span><br><span class="line">git branch</span><br><span class="line">git checkout source</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">下列两步可酌情跳过</span></span><br><span class="line"><span class="meta">#</span><span class="bash">拉取远程代码，再把刚才添加的Hexo源文件代码push到<span class="built_in">source</span>这个分支。</span></span><br><span class="line">git pull origin master</span><br><span class="line">git push -u origin source</span><br></pre></td></tr></table></figure><h4 id="在Github上备份源文件"><a href="#在Github上备份源文件" class="headerlink" title="在Github上备份源文件"></a>在Github上备份源文件</h4><p>本地的博客源文件的修改就可以直接用git命令push到repo的source分支上了，通过如下命令将本地文件备份到Github上，假设目前在hexo博客的根目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">添加修改内容到本地仓储</span></span><br><span class="line">git add .</span><br><span class="line"><span class="meta">#</span><span class="bash">提交修改内容到本地仓库</span></span><br><span class="line">git commit -m "Backup"</span><br><span class="line">git push [-f] origin source</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">或者配置push，以方便后期直接git push推送</span></span><br><span class="line">git push --set-upstream origin source</span><br><span class="line"><span class="meta">#</span><span class="bash">将本地分支和分支下的内容推送到远程</span></span><br><span class="line">git push</span><br><span class="line"><span class="meta">#</span><span class="bash">注意：执行 git push --<span class="built_in">set</span>-upstream origin <span class="built_in">source</span> 命令之后，以后修改博客源文件代码之后，直接使用git push不用再指定分支，就可以把代码push到<span class="built_in">source</span>分支上了。</span></span><br></pre></td></tr></table></figure><h4 id="结语及注意事项"><a href="#结语及注意事项" class="headerlink" title="结语及注意事项"></a>结语及注意事项</h4><p>建议先备份文件再生成博客。即先执行[git add .],[git commit -m “Date-Backup”],[git push origin source]将博客备份完成，然后执行hexo g -d发布博客。</p><p>确保hexo deploy推送的是master分支，hexo目录下的_config.yml文件通常会配置deploy推送的目标地址，这个一般在最初使用hexo时，就会配置为master，无需改动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Deployment</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Docs: https://hexo.io/docs/deployment.html</span></span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/KuiperSirius/KuiperSirius.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>更换设备后，在配置好Hexo的环境下，把博客源文件代码克隆下来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone ****** (Your repo address)</span><br><span class="line"><span class="meta">#</span><span class="bash">博客源文件下载下来之后，默认的分支是master，需要切换到<span class="built_in">source</span>分支。</span></span><br><span class="line">git checkout master/source</span><br><span class="line"><span class="meta">#</span><span class="bash">然后切换到博客目录依次执行以下命令</span></span><br><span class="line">npm install hexo</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>注: 上述操作存在不完善的地方，仍然建议使用Google Drive/One Cloud等云存储备份站点文件。themes目录以内中的主题文件夹存在的.git目录，因为一个git仓库中不能包含另一个git仓库，否则提交主题文件夹会失败，出现远程仓库无法备份theme/next主题的问题。<br>详见:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpc3NuYW4vaGV4by10aGVtZS1uZXh0L2lzc3Vlcy85MzI=" title="https://github.com/iissnan/hexo-theme-next/issues/932">https://github.com/iissnan/hexo-theme-next/issues/932<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;
Hexo静态部署到托管平台很方便，考虑到异地更新并提交Hexo博客内容的需求，可以考虑通过仓库的多分支来解决。hexo部署命令生成的静态网址默认是保存在github_name/github_name.github.io的master分支上，因此，可以在原有的基础上增加一个hexo_source分支保存网址原始数据，并将这个分支设置为默认分支。如此以来，系统环境配置完成后，每次恢复和迁移文件时候只需要git clone即可获取迁移的文件了。 
&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.kixcs.com/categories/technique/"/>
    
    
      <category term="GitHub" scheme="https://blog.kixcs.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>西方哲学史 希腊哲学 [美]弗兰克·梯利</title>
    <link href="https://blog.kixcs.com/archives/25c7/"/>
    <id>https://blog.kixcs.com/archives/25c7/</id>
    <published>2020-02-27T11:44:56.000Z</published>
    <updated>2020-03-01T14:21:05.473Z</updated>
    
    <content type="html"><![CDATA[<p class="description">很少有民族的发展能够远远超出神话阶段，除去希腊，其他民族可能都没有发展出一一种真正的哲学。基于此，论述就从希腊人开始。他们不仅为后来所有的西方思想体系奠定基础，而且几乎提出了两千年来欧洲文明研究的所有问题和答案。从简单的神话开端发展到复杂全面的体系，他们的哲学是所有民族提供的例证中的最好例证之一。激励着希腊思想者的独立精神和对真理的爱从未被超越过，也极少有能与之匹敌者。对于较深的思辨思想感兴趣的研究者来说，研究希腊哲学应当是一件有吸引力、有价值的锻炼。</p><a id="more"></a><h4 id="第一节-希腊哲学史"><a href="#第一节-希腊哲学史" class="headerlink" title="第一节 希腊哲学史"></a>第一节 希腊哲学史</h4><p>我们说的希腊哲学史是指在希腊起源并得到发展的理智运动。但是我们不仅应当将希腊人自己的体系，而且应当将那些展现希腊思想特征并兴盛于雅典、罗马、亚历山大或小亚细亚等地的体系包括在内，因为这些体系很明显是希腊文明的产物。</p><h4 id="第二节-环境"><a href="#第二节-环境" class="headerlink" title="第二节 环境"></a>第二节 环境</h4><p>我们要研究其哲学的这个民族居住在多山的希腊半岛，这一区域的自然特征很适合个强壮有活力的民族发展。这里有许多港口，有利于航海和商业，为移民到各岛屿及大陆提供了口岸。希腊的殖民地从大陆到小亚细亚海岸，最后到埃及、西西里、意大利南部和赫拉克勒斯的石柱，构成了一条连续的链条;这些殖民地并没有同宗主国失去联系，在和有着不同风俗、传统和制度的民族的积极交往中，他们轻易从中获利。</p><p>由这些条件带来的令人惊异的经济进步，商业、工业和贸易的发展，城市的兴起，财富的积累和日益增加的劳动分工，这些都对整个希腊的社会、政治、理智和宗教生活产生了深刻的影响，为-个新的、更加丰富的文明开辟了道路。这一自然和人文环境有助于激励理智和意志;它给人们的生活和世界- -个更加宽阔的事业，激发了人们的批评和反思精神，促进了独特人格的发展，促成了人类思想和行动各个方面的发展。一个民族生来就具有敏锐的智慧、对知识的热望、精致的美感、注重实际的精力和雄心，这-环境为这个民族磨炼其力量和才能提供了物质资料，让它能够在政治、宗教道德、文学和哲学领域取得快速进步。</p><h4 id="第三节-政治"><a href="#第三节-政治" class="headerlink" title="第三节 政治"></a>第三节 政治</h4><p>在其本土和殖民地的希腊城邦的命运呈现了某些共同特征:任何地方都是从部族首长专制经过贵族统治进而演化到民主制。《荷马史诗》 所描述的社会是一个等级社会，政体形式是部族首长专制。少数人对财富和文化的获取导致了贵族统治形式的建立，随后是寡头政治的建立。随着社会条件的改变，公民阶级(平民)出现并开始夺取特权阶级的领导权。从贵族制到民主制的转变，公元前7世纪和6世纪，那些勇敢而负有雄心的人不断尝试从君主手中夺取权力，僭主制在整个希腊世界得以确立。最后人们自己掌握政权，僭主制让位于民主制。</p><h4 id="第四节-文学"><a href="#第四节-文学" class="headerlink" title="第四节 文学"></a>第四节 文学</h4><p>我们可以将这些变化中的社会和政治条件视为希腊人意识觉醒的结果。新运动既是启蒙的征兆，又是其原因:它是对传统日渐增长的反思和批评的外在标志:它产生于对旧制度的反对和变革的要求。公元前6世纪的希腊文学史显示了反思和批评精神的发展，这同它在政治生活中的发展相似。以反映童年时代的天真为特征的荷马式乐观和客观性渐渐消失，诗人变得不太乐观，更加有批判性和主观性。</p><p>甚至在荷马的著作中我们也发现了他对人类行为偶然的道德反思，反思凡人的愚味，生命的悲惨、短暂以及不正义的邪恶。在赫西俄德的著作中，批评和悲观的气氛更加浓厚;他的《工作与时日》是一本道德手册，这本书严厉批评了时代的弊端，提供了道德准则和生活中的实用守则，赞扬了朴素的美德,并悲叹过去的美好时光。公元前7世纪的诗人(阿乐凯奥斯、西蒙尼特斯、阿尔基洛科斯)以伤感和讽刺的笔调谴责僭主制的出现并悲叹人类的弱点，但是力劝他们要勇敢承受命运，让诸神来决定结果。</p><p>这种教诲的和悲观的精神在公元前6世纪的诗歌中甚至更加明显;民族的政治命运成为谈论的主题，事物的新秩序受到谴责(通常更加严厉)。这一时期有寓言作家伊索和所谓的格言诗人(梭伦、甫西里第斯、特奥格尼斯)，他们明智的准则包含了伦理反思，可以被认为是道德哲学的萌芽。个人开始分析和批评人生一而不只是在过活。他在考虑人生的意义不再满足于表达民族传统的思想和观念，被激励着去提出他个人的伦理、政治和宗教的思想、希望。实际上这一从更大范围更复杂的经验中产生的探.索和不满的精神在对人类行为以伦理和政治理论为形式的哲学研究中达到了顶峰。希腊人的宗教生活对于研究他们的哲学史来说特别重要，但是在希腊世界，宗教和哲学之间的关系既密切又复杂，因此对这种关系的概述必须忽略许多重要的考虑。而且柏拉图之前时期的历史证据非常不完整，没有定论，以致权威们在许多重要观点上争论不休。</p><h4 id="第五节-希腊哲学的宗教起源"><a href="#第五节-希腊哲学的宗教起源" class="headerlink" title="第五节 希腊哲学的宗教起源"></a>第五节 希腊哲学的宗教起源</h4><p>希腊宗教有两个主要方面:一个是关于奥林匹亚诸神的宗教，通过《荷马史诗》而为人熟知。在史诗中，虽然规模宏大，但诸神展示了人类具有的情感和对人类事务的关心。这一模拟人的形象的思想从早期一直到公元前5世纪和4世纪希腊文明的顶峰，经历了一个长期加工的发展过程。这一发展与哲学的发展有着错综复杂的关系。希腊宗教的另一方面作为其首要特征与所谓的神话崇拜有关联，这一方面在公元前6世纪的宗教复兴中变得很重要。</p><p>在处理希腊宗教和希腊哲学之间的相互作用之前，我们应当指出，在基督教中的情形相比，在希腊历史中宗教、艺术和哲学相互交融的程度要更大。作为诸神中的至高无上者，宙斯这一概念的发展可以作为一个例证。在荷马的著作中，宙斯像其他神一样服从命运，但是在几个世纪后，在埃斯库罗斯的戏剧中，命运自身己经被等同于宙斯至高无上的意志。奥林匹亚诸神的宗教影响了哲学，反过来也受到哲学独立发展的概念的影响，并和我们已经提及的公元前6世纪的宗教复兴相互影响。有专家认为荷马时期服从于命运的神的概念根植于产生最初的希腊哲学一公元前6世纪的米利都学派的自然哲学的思想观点，米利都学派的思想被认为更是关乎科学的。我们将在稍后讨论这一点。当然米利都学派哲学的后来发展无疑与毕达哥拉斯、巴门尼德和赫拉克利特的哲学(他们都受到了公元前6世纪新的和十分不同的宗教虔诚的影响)一起为我们在埃斯库罗斯的宙斯那里发现的神话倾向提供了一个理智背景。这些哲学和其他各种影响混合在公元前4世纪的柏拉图和亚里士多德的哲学–神论中。</p><p>当哲学至少能够与希腊理智生活的其他要素区分开来的时候，人们通常发现某一时期的宗教精神不但存在于神话和偶像崇拜的表述中，也存在于哲学中，这并不出人意料。事实上，因为希腊宗教从未有过一-个高度有组织和专门化的形式，希腊人通常将其宗教信仰表述在艺术、诗歌和哲学中。我们必须将注意力转向诗歌，来考察哲学和希腊宗教的第一方面一对奥林匹亚诸神的崇拜之间的最初关系，这在所有关于这些形式的解释中是有代表性的。</p><p>荷马当然是不神学家，如果我们相信神学与传播宗教教义有关，他至少不是这一意义上的神学家。但是关于上帝的思考在赫西俄德的著作中已经相当理智化。他的《神谱》被认为创作于公元前8世纪，是一组叙事 史诗中最重要的，在这些叙事史诗中，人们第一次试图以传统神话作为其思考基础，从神圣存在者的角度来解释与他们有关的世界现象。事实上，就这样的著作在更加宽泛的意义上讨论宇宙结构而言，它们涉及了宇宙论:当它们涉及诸神的本性时，它们就是属于神学领域的思考:当重点分别放在世界和诸神的起源时，我们称其为宇宙进化论和神统系谱学。在赫西俄德看来，即使诸神开始存在，他所探究的学说是:产生是所有事物的根源，即使他是在考察最终的起源，他也不会提出这一问题:不能产生自身的事物是否需要产生的来源。因此在宇宙进化论和神统系谱学并存的语境中，他断言先于一切事物的卡俄斯(在真空的意义上)开始存在，在卡俄斯之后天和地开始形成:厄洛斯或者爱-他自己与天和地处于同一时期一-使 得天和地结合。从这一结合中厄洛斯的力量又产生了一系列的结合:具有宇宙进化重要意义的一群，其中世界的自然力量被赋予诗歌和神话解释，黑暗和夜晚产生了白天，大地由天孕育而产生河:具有宇宙进化理论和神统系谱学相混合的重要意义的一一群，其中提坦从天和地的结合中产生，他们最终被由宙斯和其他奧林匹亚诸神所代表的更加有秩序的力量所取代。</p><p>在较晚的时代，亚里士多德称赫西俄德及其同类人为早期原始的神学家，并将他们的方法与最早的哲学家的方法进行比较，得出结论认为这些神谱作家宣扬思想并以神话形式进行解释，而最早的哲学家是用严格的证明方法进行思考。这一区分有些道理，但是很明显神谱虽然在严格意义上不是哲学，却为哲学准备了基础。在同荷马的神话方法的比较中存在着一个 朝向理性解释的进步:在赫西俄德的著作中掌握着诸神的产生和关系的厄洛斯，与荷马著作中命运的神话概念相比，是朝向自然法观念的一个进步;相应地，有人认为在赫西俄德的厄洛斯概念中存在着单一自然原则这一概念的发端， 这一原则是后来哲学家的特点。但是一般说来，早期的神谱作家不是以一种我们现在所理解的科学和逻辑的方法来解释事物的起源，而是使用了诗歌的想象和流行的神话。希腊的第一个哲学学派，即米利都的自然哲学家组成的学派，产生于公元前6世纪。其成员有泰勒斯、阿那克西曼德和阿那克西米尼，他们以希腊小亚细亚的主要城市米利都的伊奥尼亚城为活动中心。伊奧尼亚那个时候是希腊庞大殖民帝国的一个重要部分，作为帝国基础的海洋贸易已经开始改变希腊社会早期的封建特征。官方的奧林匹亚诸神崇拜曾长期处在贵族地主家族的控制之下，在那个时候已经成为一种习俗，受到怀疑论的检查。(我们很快将要研究的公元前6世纪的宗教复兴当然是完全不同的问题。)在这样一个繁忙和务实的社会，这些最初的哲学家从对世界的神话式理解朝向通过感官获得的经验为基础的知识发展。他们哲学思考的起点是“存在的事物”，在那时这一表述包括了感官所能感知的一切:他们的目标是要确定这些事物的本质，或者自然(physis) 。但是在这点上，不能认为这一新的思考方式与早期的宇宙进化理论和神统系谱学思考有着巨大差别。因为那时自然(physis) 并没有我们用来翻译它的本质(nature)一词的含义。这个词最初与生长行为有关，与生长的来源有关，因此寻求事物的本质就是寻求基本的、现存的、生成的实在，万事万物从这一实在中产生。</p><p>对这样一个最终原则的探寻超出了赫西俄德关心的范围，但是他与米利都学派的观点有一点相似之处，在两者中，实在都是按照成长和生成来思考的。在以下两个事实间存在着进一步的相似: 一个事实是， 米利都学派认为基本的实在一当然他们可能用其他的词来表述一从根本 上讲是- -， 虽然它会按照某个适当原则将自己分为各种要素:另一个事实是，《荷马史诗》中的命运分配给诸神不同的职责。但是赫西俄德和这些(被认为更具科学性的思想者的)最初哲学家的观点之间最重要的相似之处可能在于他们对于神(the Divine) 这一表述的使用，他们都将其作为他们思想得以建立的基本原则的名称。</p><p>这一表述的意义在于，对它的应用并不必然限制在人身上，而是可以延伸到抽象的事物上。最初的哲学家将自然和神明确等同起来，这种等同主要并不是以前宗教意义上的等同;但它使希腊宗教范围持续扩展，并深化了这一宗教， 因为它代表了一种对神的探究，这一探究在赫西俄德那里并没有出现。当阿那克西曼德将他的基本解释性原则称为无定或无限的“神”，当泰勒斯如传说告诉我们的那样，说“万事万物都充满了神性”，这就回溯到了一种不太具有科学性的思考方式。但是人们所关心的这些与万物起源有关的问题非常深奧，以前的神话已经不能给出令人满意的回答。神的观念相应地得到了扩展和深化。诸神以前那些令人尊敬的属性现在被转化为这一基本的实在，被称为本质或者自然，人们用原来即存在的、不朽的、包容一切的、统治一切的等充满热情的语词来谈论它，无疑表明他们非常尊敬科学。</p><p>在这一发展过程中，与泰勒斯、阿那克西曼德和阿那克西米尼所作的最初表述相比，自然包含了新的和可能更加丰富的洞见:当心灵或者作为自然的一种解释的努斯(nous)的概念越来越突出时，希腊的神的观念恢复到了原来的神人同性论，虽然是在一个更高的水平上。</p><p>公元前6世纪宗教情感的复兴激发了希腊人的才智，这一复兴应当归于一种类型的崇拜，这一崇拜与对奥林匹亚诸神的颂扬相比，更多地起源于平民的谦卑性质。虽然荷马的诗歌在很大程度上忽视了本地的神衹，希腊人崇拜奧林匹亚诸神，并同他们站在一起，但本地神衹在人们同土地的抗争中表现出了强大的力量。</p><p>实际上，与贵族神话中的神衹相比，这些神衹享有更为重要的仪式上的重要性。他们保留着以前的特征，甚至奥林匹亚诸神的名字也开始依附于他们。他们现在获得了承认。从公元前8世纪希腊殖民地扩张就开始的政治和经济变化达到一定程度，这被专家们用来证明“阶级冲突”这一表 述实际应用的合理性。</p><p>新的宗教狂热是更加广泛的平民阶层权力日益增长的标志。当大量的乡村人因为经济变化而离开农村时，一种原来在乡村的崇拜形式就进入到城市:通常君主将对这些新神衹的崇拜作为一种煽动方式加以鼓励，这已成为当时的一个特征。狄俄尼索斯，一个具有野蛮一面的色雷斯神衹，对他的崇拜是在希腊乡村的一次归化后被引入雅典的，他迅速在阿波罗的祭司那里受到了欢迎。</p><p>得墨忒耳，一个希腊本土乡村的女神，也迅速被同化为奥林匹亚的神衹。对狄俄尼索斯的崇拜处于宗教复兴的狂热一面的核心。像其崇拜以艾留西斯为中心的得墨忒耳一样，狄俄尼索斯与春天大地的复苏联系在一起，以神衹死后的复活或者消失后的回归作为象征。在阿提卡，狄俄尼索斯作为酒神而受到崇拜，而得墨忒尔则作为丰收女神受到崇拜。对狄俄尼索斯的崇拜在不同地方会有所不同，但是它们都有相同的核心仪式:神秘仪式。新教徒通过这一仪式而被认为实现了与神衹合一，而这一神秘仪式在整个希腊广泛散播。</p><p>除了包含神秘仪式(这一希腊术语的拉J语形式后来成了我们使用的词语“圣礼”(sacrament) )的神秘崇拜外，这一崇拜还存在着公共和官方形式。在狄俄尼索斯崇拜的情形中，神秘仪式通常具有狂欢的特征，但是经过了修改以便更易于被市民接受:众所周知，实际上与对狄俄尼索斯的公共崇拜相联系的庆祝活动与阿提卡戏剧的演变有很大关系。对狄俄尼索斯的崇拜仪式和与奧菲斯这一名 字有关的狄俄尼索斯宗教混合起来，从而经历了进一步的修正。奥菲斯是一个神话中的色雷斯歌手，他用里拉琴演奏，不仅使人和动物着迷，也令神衹着迷。奥菲斯希望用他令人愉快的音乐说服冥王的王后让他的爱人复生，但是最后却被狄俄尼索斯狂暴的女祭司撕成碎片。这样他就被等同于这一神衹，在一个狄俄尼索斯神话的奥菲斯式版本中，狄俄尼索斯也在重生之前被撕成碎片。这一奧菲斯式影响在狄俄尼索斯运动中与其背景相比具有更少的原始性，在与神衹合一而追求永恒的努力中，这一影响包含了伦理要素。我们已经注意到，狄俄尼索斯崇拜是如何通过接受城市的平民生活而失去了很多原始特征的。奥菲斯运动代表了对这一宗教运动的一个进一步的加工，因此很容易理解为什么一位专家认为奧菲斯是被驯服和穿上衣服的狄俄尼索斯。</p><p>在公元前6世纪的宗教复兴中，能够在哲学中追溯的大多数影响可以被认为是奥菲斯教的影响。在这些影响中首先是奧菲斯教灵魂学说的影响，特别是毕达哥拉斯兄弟会所接受的奥菲斯教的修正形式。奥菲斯教相信灵魂的轮回，灵魂被认为是不朽的，从神圣状态经历最初的下降，在接下来的转世化身中，灵魂又努力回到神圣状态。这一伦理上的关注在很大程度上修正了狄俄尼索斯教将重点放在大地的复苏上。在毕达哥拉斯的著作中，通过将灵魂原则等同于心灵，在稍晚的阿那克萨戈拉的类似倾向中，他们为柏拉图和亚里士多德所坚持的观点铺平了道路，后两人所持观点涉及到神性原则的理智特征和这一特征与人类灵魂的联系。从总体上看，公元前6世纪的宗教复兴并没有为哲学提供教条式的预设，反而为宗教虔诚导向的思想发展提供了良好的背景。毕达哥拉斯学派、巴门尼德及赫拉克利特的哲学都显示了与其同时代宗教生活的一致性，而没有反思宗教生活的直接影响。这些哲学家用热情和个人品质在表达自己，这让人想起同时代的诗人埃斯库罗斯和品达，人们也可以说公元前6世纪宗教生活的最好例证出现在这些哲学家和诗人的著作中，而不是出现在神话崇拜中。</p><p>此处所提及的三种哲学都意识到了米利都学派自然哲学的背景，这种哲学虽然涉及到“神”，却首先对呈现在感官感知中的物质和事物充满空间的方面感兴趣。毕达哥拉斯学派、巴门尼德和赫拉克利特保留了米利都学派的唯理论:他们就像米利都学派的“自然哲学家”，但是他们更多强调了对神的理解。毕达哥拉斯学派对宇宙论感兴趣，这在柏拉图那里得到响应，但是他们学说的核心是关于“一”或者“单一”(monad) 的观念，按照他们说的神秘主义，各种各样的可见物体从“一”中产生:统治这个不完善现象世界的存在的理性汇集在这个“一”的本质中。而且，既然所有的存在都从“一”中产生，就必须回到“一”中，可见世界受到贬损，所有的价值和完善都归于这个“一”。很明显，此处与奥菲斯教义中关于灵魂从最初的神圣状态下降的表述是相似的。奥菲斯教的情感主义在这里被进一步遏制，他们把更大的重要性分配给对理论意义上的智慧的追求，理论是对理性和永恒真理的沉思:但同时奥菲斯教的实质洞见在毕达哥拉斯学派的“哲学是一种生活方式”的观点中保存下来。</p><p>对于巴门尼德和赫拉克利特来说，神性原则也被认为是“一”， 这种一神论倾向在晚期希腊哲学中非常重要。巴门尼德将变化的因而是虚幻的感知世界和实在世界区分开来，实在世界是不变的和神圣的存在，可以通过理性的洞察而达到。他将关于这一神 圣实在的知识称为真理之路，用通过神启得来的赞美和虔诚的措辞来表述他对真理之路的体验。各种各样变化的事物如果可以描述，则完全是虚幻的，只能经由被命名为意见之路的宇宙论来把握，在其中“没有真的信念”。真理之路和意见之路这一区分的伦理特征就是奥菲斯教对灵魂的神圣状态和下降状态所作的区分。</p><p>赫拉克利特的学说也坚持了前述观点中的一神论和唯理论预设，虽然他没有贬损感觉世界。他将一个基本的和神圣的原则等同于火。灵魂实体，或者自然通过量度或者理性而得到限定，理性使得可见世界永不停息的所有变化都成为-种交换，因为理性使得所有的对立面保持和谐。赫拉克利特显然反对许多骗子的活动，这些骗子利用了神话崇拜的流行:但是他晦涩难懂的表述无疑具有一种宗教特征，他当然也对他的出生地伊奥尼亚发展出的最早的科学性没有兴趣。</p>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;
很少有民族的发展能够远远超出神话阶段，除去希腊，其他民族可能都没有发展出一一
种真正的哲学。基于此，论述就从希腊人开始。他们不仅为后来所有的西方
思想体系奠定基础，而且几乎提出了两千年来欧洲文明研究的所有问题和答案。从简单的
神话开端发展到复杂全面的体系，他们的哲学是所有民族提供的例证中的最好例证之一。
激励着希腊思想者的独立精神和对真理的爱从未被超越过，也极少有能与之匹敌者。对于较深的思辨思想感兴趣的研究者来说，研究希腊哲学应当是一件有吸引
力、有价值的锻炼。
&lt;/p&gt;
    
    </summary>
    
    
      <category term="文学" scheme="https://blog.kixcs.com/categories/literature/"/>
    
    
      <category term="History" scheme="https://blog.kixcs.com/tags/History/"/>
    
  </entry>
  
  <entry>
    <title>关于网络异常流量清洗系统的若干思考</title>
    <link href="https://blog.kixcs.com/archives/3ac5/"/>
    <id>https://blog.kixcs.com/archives/3ac5/</id>
    <published>2020-01-03T13:58:32.000Z</published>
    <updated>2020-03-01T12:23:49.816Z</updated>
    
    <content type="html"><![CDATA[<p class="description">随着网络技术和网络经济的发展，网络的重要性日益突出。与此同时，网络中存在的安全漏洞也在相应的增加，网络安全问题所造成的影响也越来越大，另一方面给企业和社会的影响带来了恶劣影响。据显示，DDoS攻击中，90%以上属于TCP协议栈攻击)，因此在当前大流量、分布广、隐蔽性强的DDoS攻击环境下，如何有效防范DDos攻击对维护当前网络稳定性与安全性具有重要意义。而伴随着计算机的不断普及与应用，在大规模DDoS网络流量下，传统防范技术对服务器的防范能力已不再奏效。</p><a id="more"></a><p>企业传统的DDoS攻击防御方式往往只能被动的不计成本的采用不断提升服务器性能和带宽的方式来保障自己企业的正常业务所需要的资源。随着DDoS攻击的规模不断增大，攻击手段不断智能化，这种通过预留资源的方式防御DDoS攻击的效果日益不明显。因此，专业的DDoS攻击防御方案对现今的企业核心网络业务保障来说显得尤为重要。</p><p>从城域网中接入的用户角度来看，在面临大量DDoS攻击的情况下，企业需要升级当前DDoS攻击防御系统，然而DDoS攻击自身的复杂性导致了企业难以独立完成对DDoS的防御；从运营商的角度来说，通过对城域网中大量的DDoS流量的过滤，可以有效减少城域网自身的负载，为城域网的业务提供有效的保障，同时也能够促进自身的发展；综上所述，在城域网侧为企业客户开展流量清洗实现对DDoS攻击的防御，可以同时满足运营商和大客户的双重需要，已经成为目前运营商的必然需求。</p><p>自1999年8月第一起DDoS攻击发生以来，人们就对DDoS攻击及其对策展开了深入的研究。1999年11月，CERT/CC发表的Distributed-Systems Intruder Tools Workshop报告中，最早全面阐述了DDoS攻击的原理，并针对系统管理员、ISP、以及事件响应小组，从预防、检测、响应三方面依次给出了即时、短期、长期的解决方案。随后，SANS和Cisco Systerms等几个著名的安全组织、公司，也针对DDoS攻击的防御提出了见解。华盛顿大学的Dave Dittrich在Distributed Denial of Service(DDoS)Attacks/tools提出了最新的DDoS攻击及防御的研究资料。在攻击工具研究方面，许多DDoS攻击工具(如: Trinoo、 TFN、Stacheldraht、TFN2K、Shaft、 Mstream 等)被详细地分析。一方面为防御DDoS攻击提供重要参考，另一方面攻击者利用相关信息进一步改进攻击工具。Mixter在Tribe Flood Network 3000中对DDoS攻击工具进行了理论性的评价，并给出了网络入侵检测规则。</p><p>在防御研究方面，人们从攻击前防御、攻击期间防范和攻击后防御等方面对DDoS防御措施进行了深入研究,研究的方向主要体现在攻击中的检测与过滤技术以及攻击后的攻击源追踪技术。Farguson和Senie基于DDoS攻击伪造源IP地址的特性，提出了入口报文过滤技术。该技术从理论来说，能够有效杜绝DDoS攻击，然而就实现而言，部署难度大不易实施。Park和Lee提出的基于路由报文过滤机制。该技术使用BGP信息来识别伪造源IP地址的报文。实验表明，如果采用此方案有效防范DDoS攻击，就需要在18%的Internet核心路由器上部署该机制，同样，该方案的部署仍然困难。</p><p>目前，研究主要通过在受害者和ISP网络上游部署检测与过滤机制，进行攻击报文过滤。其弊端在于，当大规模的DDoS攻击发生时，该机制的防范效率明显降低。Bellovin在Internet Draft:ICMP Traceback Messages中提议，利用路由器向目的IP发送ICMP Traceback Messages重建攻击流的路径。Barros基于Bellovin的方案进行了改进，以适用于反射式DDoS攻击。</p><p>2000年，Burch 和Cheswick提出通过报文记载其路由信息。路由器在报文头部(随机或确定)写入地址信息，接收方根据此报文构建路由路径。Savage等深入的研究了概率性报文标记机制，并提出地址信息标记方法。随后，Song 和Perrig提出了更为精简的报文标记算法，该算法的路径恢复更加快捷。Snoren 等提出基于Hash的IP Traceback技术，该技术利用源路径重构攻击流路径。当DDoS攻击存在大量攻击源时，IP Traceback技术追踪攻击源的效率会明显下降。在DDoS预防、攻击缓解和攻击流偏转、以及攻击记录的分析等方面，不少研究集中于网络和主机DDoS攻击下的可存活性研究以及构建DDoS攻击容忍网络。从国内外对DDoS研究的现状来看，在大规模DDoS攻击的情况下，很多DDoS防范技术的防御能力效率显著下降，攻击者通过对攻击工具的改进，很容易向目标机器发起DDoS攻击，因此DDoS防范措施还需要进一步改进。</p><p>随着计算机的不断普及与应用，在大规模DDoS网络流量下，传统防范技术对服务器的防范能力已不再奏效。基于此种情况本文提出了流量清洗的方法来防范SYN Flood攻击。大量攻击者通过占用带宽和抢占资源方式致使目标服务器发生拒绝服务，进而影响了运营商和企业的正常业务。</p><p>针对SYN Flood攻击隐蔽性强、规模大等特点，本文提出了流量清洗防范的思想。流量清洗防范采用层次过滤的方式，将网络总流量区分可信源流量、不可信源流量和未知源流量，并根据网络状态进行具体处理。基于用户需求，将流量清洗系统划分为功能模块和公共模块。功能模块包括统计分析模块、流牵引模块、清洗平台和半连接处理，公共模块包括特征库模块和总连接计数模块。统计分析模块进行黑名单和白名单匹配，完成对网络流量的初步过滤;流牵引模块通过设置SYN速率限值，判断是否需要对异常流量二次过滤;半连接处理接收清洗平台处理结果，建立生成动态列表信息，并更新特征库参数;总连接计数模块处理IN方向和OUT方向的报文，完成特征库全连接总数的更新。</p><p>流量清洗系统基于需求设计实现后，对网络流量进行了层次过滤。从验证结果来看，系统对攻击者识别的准确率提高，同时也增强了对SYN Flood攻击的处理与防御能力。</p><p>为了提高企业或运营商在遭受大量DDoS攻击时对DDoS的防御能力，流量清洗系统欲采用网络流量层次性过滤的思想，通过对整体流量进行区分处理。对设备接收的流量区分为可信源流量、未知源流量和不可信源流量，并针对三种流量依次诵过系统相关模块进行初步讨滤、二次过滤、cookie验证和建立动杰名单等外理。流量清洗系统根据用户需求将整体系统划分四个主要模块(包括统计分析模块、流牵引模块、清洗平台和半连接处理)和二个公共模块(总连接计数和特征库模块)。以下模块为论文所涉及的主要工作:</p><ul><li><p>在统计分析模块中将对流量进行初步过滤。对IN方向的流量，通过黑、白名单匹配，放行可信源流量。根据当前网络状态，对未知源和不可信源流量，判断是否需要对报文做丢包处理。</p></li><li><p>在流牵引模块中，将对进入设备的流量进行二次过滤。通过设置SYN限值判断是否对未知源流量和不可信源流量进行清洗处理。</p></li><li><p>在半连接处理中，将通过接收清洗平台处理结果，生成动态列表信息，包括动态白名单列表和动态黑名单列表，并更新特征库相应参数信息。</p></li><li><p>总连接计数模块的处理主要集中报文的IN方向和OUT方向，根据接收报文类型进行相关处理，并完成对特征库中全连接总数的更新。</p></li></ul><p>流量清洗系统划分为功能模块和公共模块。功能模块包括统计分析模块、流牵引模块、清洗平台和半连接处理，公共模块包括特征库模块和总连接计数模块。</p><p>统计分析模块从特征库中获取黑、白名单列表信息，完成刘流量区分，并依据网络状态对总体流量进行初步过滤。</p><p>流牵引模块在统计分析模块处理的基础上，对网络流量进行第二次过滤。通过设置SYN限值，判断是否需要对未知源流量和不可信源流量做清洗处理。</p><p>半连接处理通过接收清洗平台的处理结果，生成动态列表信息，包括动态白名单列表和动态黑名单列表，并更新特征库相应参数。</p><p>总连接计数模块的处理主要集中报文的IN方向和OUT方向，通过对总连接计数模块的处理完成特征库中全连接总数的更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;
随着网络技术和网络经济的发展，网络的重要性日益突出。与此同时，网络中存在的安全漏洞也在相应的增加，网络安全问题所造成的影响也越来越大，另一方面给企业和社会的影响带来了恶劣影响。据显示，DDoS攻击中，90%以上属于TCP协议栈攻击)，因此在当前大流量、分布广、隐蔽性强的DDoS攻击环境下，如何有效防范DDos攻击对维护当前网络稳定性与安全性具有重要意义。而伴随着计算机的不断普及与应用，在大规模DDoS网络流量下，传统防范技术对服务器的防范能力已不再奏效。
&lt;/p&gt;
    
    </summary>
    
    
      <category term="随想" scheme="https://blog.kixcs.com/categories/thinking/"/>
    
    
      <category term="DDoS" scheme="https://blog.kixcs.com/tags/DDoS/"/>
    
  </entry>
  
  <entry>
    <title>浅析Google人工智能系统TensorFlow</title>
    <link href="https://blog.kixcs.com/archives/4cb2/"/>
    <id>https://blog.kixcs.com/archives/4cb2/</id>
    <published>2019-10-26T13:39:16.000Z</published>
    <updated>2020-03-01T12:11:51.056Z</updated>
    
    <content type="html"><![CDATA[<p class="description">2016年3月份，Google的围棋人工智能程序AlphaGo以4比1的大比分，战胜人类选手李世石，在全球成功引起广泛关注，引起了一波人工智能的热潮。从智能手机的语音助手，到相机的人脸识别，人工智能技术已经进入到我们生活的方方面面，在未来将深刻的影响我们的生活。为了加速深度学习领域的发展，2015年11月9日，Google发布深度学习框架TensorFlow并宣布开源。在短短的一年时间内，在GitHub上，TensorFlow就成为了最流行的深度学习项目。</p><a id="more"></a><h3 id="背景及概述"><a href="#背景及概述" class="headerlink" title="背景及概述"></a>背景及概述</h3><p>关于TensorFlow，截至今天，短短的两年内，其 GitHub 库大约 845 个贡献者共提交超过 17000 次。</p><p>详细的来说，TensorFlow 是一个开源的、基于 Python 的机器学习框架，由 Google Brain 团队为深度神经网络（DNN）开发的功能强大的开源软件库，在 Apache 2.x 协议许可下可用，并在图形分类、音频处理、推荐系统和自然语言处理等场景下有着丰富的应用，是目前最热门的机器学习框架。</p><p>Google在很多年前就已经开始把深度学习的技术应用到很多产品当中，在这个过程当中，Google也迭代、开发了好几代支持深度学习的软件系统, TensorFlow现在已经演化成一个相当完整的深度学习软件开放平台。</p><h3 id="TensorFlow的应用场景"><a href="#TensorFlow的应用场景" class="headerlink" title="TensorFlow的应用场景"></a>TensorFlow的应用场景</h3><p>TensorFlow有诸多应用场景，例如: TensorFlow支持多种硬件的平台, 比如说，它支持CPU、GPU混合搭建的数据中心的训练平台，它也支持将数据中心训练好的模型，相对便捷地部署到不同的移动端应用上，可以支持类似Google自主研发的TPU处理器; TensorFlow支持多种开发环境: 支持多种硬件的平台是基础，TensorFlow一直以来的一个目标，就是能够帮助尽量多的开发者，能够把深度学习的技术利用起来，最终使得广大的用户从中能力得到益处，基于这个想法，TensorFlow一直很重视多种程序员开发环境的支持。比如说，开发者可以在主要的开发环境中使用TensorFlow。TensorFlow在Google内部的应用推广是非常全面和彻底的，比如说TensorFlow很早就帮助Google的核心业务（搜索和广告），实施了深度学习的模型，并且在核心业务上体现了它的性能。在垃圾邮件过滤中，Google也使用了TensorFlow训练的模型，同时在安卓的应用程序推荐上，也上线了TensorFlow的模型等等。TensorFlow深入移动端,</p><p>任何曾经试图在 Python 中只利用 NumPy 编写神经网络代码的人都知道那是多么麻烦。编写一个简单的一层前馈网络的代码尚且需要 40 多行代码，当增加层数时，编写代码将会更加困难，执行时间也会更长。TensorFlow 使这一切变得更加简单快捷，从而缩短了想法到部署之间的实现时间。</p><p>就TensorFlow的原理而言 ，TensorFlow 允许将深度神经网络的计算部署到任意数量的 CPU 或 GPU 的服务器、PC 或移动设备上，且只利用一个 TensorFlow API。相较于其他的深度学习库而言，如 Torch、Theano、Caffe 和 MxNet，包括 TensorFlow 在内的大多数深度学习库能够自动求导、开源、支持多种 CPU/GPU、拥有预训练模型，并支持常用的NN架构，如递归神经网络（RNN）、卷积神经网络（CNN）和深度置信网络（DBN）。</p><p>TensorFlow 则还有更多的特点，如下：支持所有流行语言，如 Python、C++、Java、R和Go；可以在多种平台上工作，甚至是移动平台和分布式平台；它受到大多数主流云计算服务平台（AWS、Google和Azure）的支持；Keras——高级神经网络 API，已经与 TensorFlow 整合；与 Torch/Theano 比较，TensorFlow 拥有更好的计算图表可视化；允许模型部署到工业生产中，并且容易使用；有非常好的社区支持；TensorFlow 不仅仅是一个软件库，它是一套包括 TensorFlow，TensorBoard 和 TensorServing 的软件。</p><p>谷歌 research 博客列出了全球一些使用 TensorFlow 开发的有趣项目：Google 翻译运用了 TensorFlow 和 TPU（Tensor Processing Units）；Project Magenta 能够使用强化学习模型生成音乐，运用了 TensorFlow；澳大利亚海洋生物学家与来自昆士兰大学（Queensland University）的计算机科学家合作，使用了 TensorFlow 来发现和理解濒临灭绝的海牛；一位日本农民运用 TensorFlow 开发了一个应用程序，使用大小和形状等物理特性对黄瓜进行分类；在医学领域，发射科的医生通过采用TensorFlow，使其在医学扫描中能够识别帕金森病的迹象。湾区的数据科学家在树莓派上使用TensorFlow来追踪记录加州火车的动态。</p><p>为了更好地理解TensorFLow,首先要明白Tensorflow 不是一个普通的 Python 库，大多数 Python 库被编写为 Python 的自然扩展形式。当开发者导入一个库时，开发者得到的是一组变量、函数和类，它们补充并扩展了代码“工具箱”。 Python 和 Tensorflow 之间的联系，可以类比 Javascript 和 HTML 之间的关系。Javascript 是一种全功能的编程语言，可以实现各种出色的效果。HTML 是用于表示某种类型的实用计算抽象（这里指的是可由 Web 浏览器呈现的内容）的框架。Javascript 在交互式网页中的作用是组装浏览器看到的 HTML 对象，然后在需要时通过将其更新为新的 HTML 来与其交互。与 HTML 类似，Tensorflow 是用于表示某种类型的计算抽象（称为“计算图”）的框架。当开发者用 Python 操作 Tensorflow 时，开发者用 Python 代码做的第一件事是组装计算图。之后第二个任务就是与它进行交互（使用 Tensorflow 的“会话”）。但重要的是，要记住计算图不在变量内部，它处在全局命名空间内。莎士比亚曾经说过：“所有的 RAM 都是一个阶段，所有的变量都只不过是指针。”</p><h3 id="TensorFlow的技术细节"><a href="#TensorFlow的技术细节" class="headerlink" title="TensorFlow的技术细节"></a>TensorFlow的技术细节</h3><p>Tensorflow的第一个关键抽象：计算图。计算图实质上是一个全局数据结构：计算图是一个有向图，捕获有关计算方法的指令。第二个关键抽象：会话。会话的作用是处理内存分配和优化，使开发者能够实际执行由图形指定的计算。可以将计算图想象为我们想要执行的计算的“模板”：它列出了所有的步骤。为了使用这个图表，开发者还需要发起一个会话，它使开发者能够实际地完成任务。例如，遍历模板的所有节点来分配一组用于存储计算输出的存储器。为了使用 Tensorflow 进行各种计算，我们既需要图也需要会话。会话包含一个指向全局图的指针，该指针通过指向所有节点的指针不断更新。这意味着在创建节点之前还是之后创建会话都无所谓。创建会话对象后，可以使用 sess.run(node) 返回节点的值，并且 Tensorflow 将执行确定该值所需的所有计算。</p><p>Tensorflow 仅通过必需的节点自动路由计算这一事实是它的巨大优势。如果计算图非常大并且有许多不必要的节点，它就能节约大量运行时间。它允许我们构建大型的“多用途”图形，这些图形使用单个共享的核心节点集合根据采取的计算路径来做不同的任务。对于几乎所有应用程序而言，根据所采用的计算路径考虑 sess.run() 的调用方法是很重要的。关于变量和副作用，对Tensorflow而言，了解变量对于使用进行深度学习来说至关重要，因为模型的参数就是变量。在训练期间，你希望通过梯度下降在每个步骤更新参数，但在计算过程中，开发者希望保持参数不变，并将大量不同的测试输入集传入到模型中。模型所有的可训练参数很有可能都是变量。</p><p>为了进一步了解TensorFlow，下面进行对TensorFlow的一些简介：</p><h4 id="张量和图"><a href="#张量和图" class="headerlink" title="张量和图:"></a>张量和图:</h4><p>TensorFlow 是一种采用数据流图（data flow graphs），用于数值计算的开源软件库。其中 Tensor 代表传递的数据为张量（多维数组），Flow 代表使用计算图进行运算。数据流图用「结点」（nodes）和「边」（edges）组成的有向图来描述数学运算。「结点」一般用来表示施加的数学操作，但也可以表示数据输入的起点和输出的终点，或者是读取/写入持久变量（persistent variable）的终点。边表示结点之间的输入/输出关系。这些数据边可以传送维度可动态调整的多维数据数组，即张量（tensor）。在 Tensorflow 中，所有不同的变量和运算都是储存在计算图。所以在我们构建完模型所需要的图之后，还需要打开一个会话（Session）来运行整个计算图。在会话中，我们可以将所有计算分配到可用的 CPU 和 GPU 资源中。</p><h4 id="常量和变量："><a href="#常量和变量：" class="headerlink" title="常量和变量："></a>常量和变量：</h4><p>TensorFlow 中最基本的单位是常量（Constant）、变量（Variable）和占位符（Placeholder）。常量定义后值和维度不可变，变量定义后值可变而维度不可变。在神经网络中，变量一般可作为储存权重和其他信息的矩阵，而常量可作为储存超参数或其他结构信息的变量。</p><h4 id="占位符和feed-dict"><a href="#占位符和feed-dict" class="headerlink" title="占位符和feed_dict"></a>占位符和feed_dict</h4><p>我们已经创建了各种形式的常量和变量，但 TensorFlow 同样还支持占位符。占位符并没有初始值，它只会分配必要的内存。在会话中，占位符可以使用 feed_dict 馈送数据。feed_dict 是一个字典，在字典中需要给出每一个用到的占位符的取值。在训练神经网络时需要每次提供一个批量的训练样本，如果每次迭代选取的数据要通过常量表示，那么 TensorFlow 的计算图会非常大。因为每增加一个常量，TensorFlow 都会在计算图中增加一个结点。所以说拥有几百万次迭代的神经网络会拥有极其庞大的计算图，而占位符却可以解决这一点，它只会拥有占位符这一个结点。</p><h4 id="TensorFlow中的神经网络"><a href="#TensorFlow中的神经网络" class="headerlink" title="TensorFlow中的神经网络:"></a>TensorFlow中的神经网络:</h4><p>输入数据集，数据集分为训练数据集和标注、测试数据集和标注（包括验证数据集和标注）。测试和验证集能赋值到constant() 中，而训练集可以导入 tf.placeholder() 中，训练集只有导入占位符我们才能在随机梯度下降中成批量地进行训练。确定神经网络模型，该模型可以是简单的一层全连接网络或 9 层、16 层的复杂卷积网络组成。网络定义的权重矩阵和偏置向量后需要执行初始化，每一层需要一个权重矩阵和一个偏置向量。构建损失函数，并计算训练损失。模型会输出一个预测向量，我们可以比较预测标签和真实标签并使用交叉熵函数和 softmax 回归来确定损失值。训练损失衡量预测值和真实值之间差距，并用于更新权重矩阵。优化器，优化器将使用计算的损失值和反向传播算法更新权重和偏置项参数。</p><h4 id="TensorFlow中的深度神经网络"><a href="#TensorFlow中的深度神经网络" class="headerlink" title="TensorFlow中的深度神经网络:"></a>TensorFlow中的深度神经网络:</h4><p>LeNet5 由两个卷积层加上三个全连接层组成，因此它是一种浅层神经网络。卷积神经网络最出名的就是 2012 年所提出的 AlexNet、2013 年的 7 层 ZF-Net 和 2014 年提出的 16 层 VGGNet。到了 2015 年，谷歌通过 Inception 模块开发出 22 层的卷积神经网络 （GoogLeNet），而微软亚洲研究院创造出了 152 层的卷积神经网络：ResNet。</p><h3 id="Google-I-O上的TensorFlow"><a href="#Google-I-O上的TensorFlow" class="headerlink" title="Google I/O上的TensorFlow"></a>Google I/O上的TensorFlow</h3><p>在2017年Google I/O开发者大会上，同时提出的还有Google Tensor Lite。TensorFlow Lite 是 TensorFlow 移动和嵌入式设备轻量级解决方案。它使设备机器学习具有低延迟和更小的二进制体积。TensorFlow Lite 同时支持 Android 神经网络 API的硬件加速。TensorFlow Lite 使用多项技术降低延迟，例如移动 app 内核优化、pre-fused 激活、允许更快更小（定点）模型的量化内核。关于TensorFlow Lite 所包含的内容，有以下几点:</p><ul><li><p>支持一系列量子和浮点的核心运算符,并针对移动平台进行了优化。它结合 pre-fused 激活和其他技术来进一步提高性能和量化精度。此外，TensorFlow Lite 还支持在模型中使用自定义操作。</p></li><li><p>TensorFlow Lite 基于FlatBuffers定义了一个新的模型文件格式。FlatBuffers 是一个开源的高效的跨平台序列化库。它与 protocol buffers类似,但主要区别是 FlatBuffers 常与 per-object 内存分配相结合在您直接访问数据时不需要再次解析包。此外，FlatBuffers 的代码体积比 protocol buffers 小很多。</p></li><li><p>TensorFlow Lite 拥有一个新的移动设备优化的解释器保证应用程序的精简和快速。解释器使用静态图形排序和自定义（less-dynamic）内存分配器来确保最小的负载，初始化和执行延迟。</p></li><li><p>TensorFlow Lite 针对支持的设备提供了一个利用硬件加速的接口。通过 Android 神经网络库，作为 Android O-MR1 的一部分发布。</p></li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>TensorFlow 是一个人人都触手可及的完全开源的机器学习框架，适用于众多领域，在研究工作以及实际产品开发中都能发挥重要的作用。Google还赋予了 TensorFlow 很快的运行速度，并使其能适应更多的应用领域。举例来说，清华大学自然语言处理实验室的研究人员已通过 TensorFlow 来加强他们对语言理解的研究工作；而像京东、小米等众多中国企业也在使用 TensorFlow。与此同时，在中国的初创公司当中，也有不少 TensorFlow 的使用者，CastBox就是其中之一。CastBox开发的播客应用程序利用 TensorFlow 对他们的用户偏好进行分析，并向听众提供个性化的推荐。</p><p>简而言之，TensorFlow 是一个端到端开源机器学习平台。它拥有一个包含各种工具、库和社区资源的全面灵活生态系统，可以让研究人员推动机器学习领域的先进技术的发展，并让开发者轻松地构建和部署由机器学习提供支持的应用。除此之外，TensorFlow可以轻松地构建模型，随时随地进行可靠的机器学习生产，以及实现强大的研究实验。</p><p>尽管人工智能已被越来越多的开发者们应用于前沿研究，或产品及服务的开发当中，但这仅仅是人工智能无限的潜力的冰山一角。人工智能的神奇之处，在于它能被应用在医疗保健、交通运输和环境保护等方方面面，为复杂的社会问题探寻解决方案。如今，在人工智能的协助下，人们得以探索全新的研究领域，开发创新的产品，让数以百万计的人类从中获益。</p>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;
2016年3月份，Google的围棋人工智能程序AlphaGo以4比1的大比分，战胜人类选手李世石，在全球成功引起广泛关注，引起了一波人工智能的热潮。从智能手机的语音助手，到相机的人脸识别，人工智能技术已经进入到我们生活的方方面面，在未来将深刻的影响我们的生活。为了加速深度学习领域的发展，2015年11月9日，Google发布深度学习框架TensorFlow并宣布开源。在短短的一年时间内，在GitHub上，TensorFlow就成为了最流行的深度学习项目。
&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计" scheme="https://blog.kixcs.com/categories/design/"/>
    
    
      <category term="Google" scheme="https://blog.kixcs.com/tags/Google/"/>
    
      <category term="TensorFlow" scheme="https://blog.kixcs.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>汉诺塔的递归算法</title>
    <link href="https://blog.kixcs.com/archives/36f2/"/>
    <id>https://blog.kixcs.com/archives/36f2/</id>
    <published>2019-10-25T10:57:04.000Z</published>
    <updated>2020-03-09T11:40:44.104Z</updated>
    
    <content type="html"><![CDATA[<p>最早发明这个问题的人是法国数学家爱德华·卢卡斯。传说越南河内某间寺院有三根银棒，上串 64 个金盘。寺院里的僧侣依照一个古老的预言，以上述规则移动这些盘子；预言说当这些盘子移动完毕，世界就会灭亡，上述又称梵天寺之塔问题。但不知道是卢卡斯自创的这个传说，还是他受他人启发。这个传说有若干变体：寺院换成修道院、僧侣换成修士等等。寺院的地点众说纷纭，其中一说是位于越南的河内，所以被命名为“河内塔”。另外亦有“金盘是创世时所造”、“僧侣们每天移动一盘”之类的背景设定。</p><p class="description"></p><a id="more"></a><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p><h4 id="规律"><a href="#规律" class="headerlink" title="规律"></a>规律</h4><p>归纳可得，当移动的盘子为n个时，移动的次数为2^n - 1。</p><h4 id="调用方法的栈机制"><a href="#调用方法的栈机制" class="headerlink" title="调用方法的栈机制"></a>调用方法的栈机制</h4><p>从主线程开始调用方法/函数进行不停的压栈和出栈操作，函数的调用就是将函数压入栈中，函数的结束就是函数出栈的过程，这样就保证了方法调用的顺序流，即当函数出现多层嵌套时，需要从外到内一层层把函数压入栈中，最后栈顶的函数先执行结束（最内层的函数先执行结束）后出栈，再倒数第二层的函数执行结束出栈，到最后，第一个进栈的函数调用结束后从栈中弹出回到主线程，并且结束。</p><h4 id="递归算法的实现-Java语言描述"><a href="#递归算法的实现-Java语言描述" class="headerlink" title="递归算法的实现(Java语言描述)"></a>递归算法的实现(Java语言描述)</h4><p>实现该递归算法可以分为三步走，首先需要把n-1个盘子从A柱移到B柱(C柱作为辅助)；然后再将第n个盘子/最大的盘子从A柱移动到C柱；最后将B柱上的n-1个盘子移动到C柱上(A柱作为辅助)即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*程序目的：利用汉诺塔函数来求出不同盘子移动的步骤</span></span><br><span class="line"><span class="comment">*2019-10-24 Summer</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Summer</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args [])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">String str;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m =<span class="number">0</span>;<span class="comment">//标记移动次数</span></span><br><span class="line">BufferedReader keyin=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">System.out.print(<span class="string">"请输入盘子数量:"</span>);</span><br><span class="line">str=keyin.readline();</span><br><span class="line">j=Integer.parseInt(str);</span><br><span class="line">hanoi(j,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p1,<span class="keyword">int</span> p2,<span class="keyword">int</span> p3)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)&#123; <span class="comment">//圆盘仅剩一个时，直接移动到C柱。</span></span><br><span class="line"> System.out.println(<span class="string">"第"</span>+(++m)+<span class="string">"次移动，从"</span>+p1+<span class="string">"移动到"</span>+p3+<span class="string">"。"</span>)</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;<span class="comment">//递归算法分三步走</span></span><br><span class="line">  hanoi(n-<span class="number">1</span>,p1,p3,p2); <span class="comment">//hanoi(int n,int p1,int p2,int p3)中，形参p2所在的位置表示过渡参数。</span></span><br><span class="line">  System.out.println(<span class="string">"第"</span>+(++m)+<span class="string">"次移动，从"</span>+p1+<span class="string">"移动到"</span>+p3+<span class="string">"。"</span>);</span><br><span class="line">  hanoi(n-<span class="number">1</span>,p2,p1,p3);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最早发明这个问题的人是法国数学家爱德华·卢卡斯。传说越南河内某间寺院有三根银棒，上串 64 个金盘。寺院里的僧侣依照一个古老的预言，以上述规则移动这些盘子；预言说当这些盘子移动完毕，世界就会灭亡，上述又称梵天寺之塔问题。但不知道是卢卡斯自创的这个传说，还是他受他人启发。这个传说有若干变体：寺院换成修道院、僧侣换成修士等等。寺院的地点众说纷纭，其中一说是位于越南的河内，所以被命名为“河内塔”。另外亦有“金盘是创世时所造”、“僧侣们每天移动一盘”之类的背景设定。&lt;/p&gt;
&lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="随想" scheme="https://blog.kixcs.com/categories/thinking/"/>
    
    
      <category term="Algorithm" scheme="https://blog.kixcs.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>浅析DNS流媒体解锁在代理环境中的应用</title>
    <link href="https://blog.kixcs.com/archives/90d0/"/>
    <id>https://blog.kixcs.com/archives/90d0/</id>
    <published>2019-09-10T11:01:20.000Z</published>
    <updated>2020-03-13T12:46:50.317Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p>在谈论DNS流媒体解锁所需的SNI代理服务器之前，先来回顾和了解下通常情况下DNS请求发出之后的整个生命周期。首先，在客户端发出基于UDP协议53端口的DNS请求后，浏览器DNS缓存机制会率先寻找本地的缓存。假如未命中缓存则调用操作系统的getaddrinfo()系统函数，向操作系统寻求解析结果。倘若操作系统的DNS缓存依旧无法响应请求，则计算机向配置的上游DNS服务器发送请求，DNS服务器经历了递归和迭代之后，成功的将解析结果返回给设备的操作系统，随后向该IP发起HTTPS连接即可。<a id="more"></a><h4 id="简述DNS解锁"><a href="#简述DNS解锁" class="headerlink" title="简述DNS解锁"></a>简述DNS解锁</h4><p>通常情况下，关于DNS流媒体解锁适用的业务场景即为通过代理服务器可以畅通无碍的访问Netflix、HBO、Amazon Prime Video等平台，由于上述平台的某些使用限制，非IDC网段的请求才能被正常的响应，否则就会遇到类似”Proxy Error”这样的错误返回值。   </p><ul><li><input checked="" disabled="" type="checkbox"> 通常情况下的访问请求<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------+       +--------------+       +-----------+</span><br><span class="line">|          |       |              |       |           |</span><br><span class="line">|  Client  +-------&gt; Proxy Server +-------&gt;  Website  |</span><br><span class="line">|          |       |              |       |           |</span><br><span class="line">+----------+       +--------------+       +-----------+</span><br></pre></td></tr></table></figure></li><li><input checked="" disabled="" type="checkbox"> 倘若代理服务器不支持访问某些流媒体网站，那么就需要在此基础上增加DNS代理。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------+       +--------------+       +------------------+      +---------+</span><br><span class="line">|          |       |              |       |                  |      |         |</span><br><span class="line">|  Client  +-------&gt; Proxy Server +-------&gt; Smart DNS Server +------&gt; Website |</span><br><span class="line">|          |       |              |       |                  |      |         |</span><br><span class="line">+----------+       +--------------+       +------------------+      +---------+</span><br></pre></td></tr></table></figure></li><li><input checked="" disabled="" type="checkbox"> 在支持访问流媒体的服务器上安装SNI代理，将远端服务器的部分流媒体流量全部转发到SNI代理服务器上，这样代理服务器也就具备了访问受限制的流媒体的能力。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                                            +-----------+</span><br><span class="line">                                            |           |</span><br><span class="line">                                        +---&gt;  Website  |</span><br><span class="line">+----------+      +----------------+    |   |           |</span><br><span class="line">|          |      |                |    |   +-----------+</span><br><span class="line">|  Client  +------&gt;  Proxy Server  +----+</span><br><span class="line">|          |      |                |    |   +-----------+      +--------------+</span><br><span class="line">+----------+      +----------------+    |   |           |      |              |</span><br><span class="line">                                        +---&gt; SNI Proxy +------&gt; Netflix/HBO  |</span><br><span class="line">                                            |           |      |              |</span><br><span class="line">                                            +-----------+      +--------------+</span><br></pre></td></tr></table></figure></li></ul><h4 id="使用netflix-proxy实现DNS解锁"><a href="#使用netflix-proxy实现DNS解锁" class="headerlink" title="使用netflix-proxy实现DNS解锁"></a>使用netflix-proxy实现DNS解锁</h4><p>该项目<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FiNzcvbmV0ZmxpeC1wcm94eQ==" title="https://github.com/ab77/netflix-proxy">GitHub<i class="fa fa-external-link"></i></span> 服务器操作系统要求为Ubuntu或者Debian，运行下列命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apt-get -y install vim dnsutils curl sudo</span><br><span class="line">curl -fsSL https://get.docker.com/ | sh || apt-get -y install docker.io</span><br><span class="line">mkdir -p ~/netflix-proxy</span><br><span class="line">cd ~/netflix-proxy</span><br><span class="line">curl -fsSL https://github.com/ab77/netflix-proxy/archive/latest.tar.gz | gunzip - | tar x --strip-components=1</span><br><span class="line">./build.sh</span><br></pre></td></tr></table></figure><p>运行完成后会给出相应用户名及密码，可以配置反向代理方便未来的维护和使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netflix-proxy-admin site=http://IP:8080/credentials=admin:password</span><br></pre></td></tr></table></figure><p>配置代理服务器的DNS服务器地址为流媒体解锁服务器IP地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">修改/etc/NetworkManager/NetworkManager.conf文件，在main部分添加<span class="string">"dns=none"</span>选项：</span></span><br><span class="line">vi /etc/NetworkManager/NetworkManager.conf</span><br><span class="line">[main]</span><br><span class="line">plugins=ifcfg-rh</span><br><span class="line">dns=none</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">修改/etc/resolv.conf文件</span></span><br><span class="line">vi /etc/resolv.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">Generated by NetworkManager</span></span><br><span class="line">search openstacklocal</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver *.*.*.*</span><br></pre></td></tr></table></figure><p>(可选)在服务器的其他地方保存resolv.conf文件的一个副本（假设放在/root）并设置一个crontab定时命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp /root/resolv.conf /etc/resolv.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">添加写保护：</span></span><br><span class="line">chattr +i /etc/resolv.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">修改生成resolv.conf的相关配置文件，譬如centos7中：</span></span><br><span class="line">vi /etc/NetworkManager/NetworkManager.conf</span><br></pre></td></tr></table></figure><p>重启网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><p>⚠新版遇到python3出问题后可更换至旧版，️新版主要是buil.sh中的一行命令：apt install python3.6，导致python环境部署失败，详情可见netflix-proxy.log。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt-get update\</span><br><span class="line">&amp;&amp; apt-get -y install vim dnsutils curl sudo\</span><br><span class="line">&amp;&amp; curl -fsSL https://get.docker.com/ | sh || apt-get -y install docker.io\</span><br><span class="line">&amp;&amp; mkdir -p ~/netflix-proxy\</span><br><span class="line">&amp;&amp; cd ~/netflix-proxy\</span><br><span class="line">&amp;&amp; curl -fsSL https://github.com/Newlearner365/netflix-proxy/archive/latest.tar.gz | gunzip - | tar x --strip-components=1\</span><br><span class="line">&amp;&amp; ./build.sh</span><br></pre></td></tr></table></figure><p>对于部署的docker容器的运行情况，可以使用docker ps -a命令来查看。</p><h4 id="使用Dnsmasq实现DNS解锁"><a href="#使用Dnsmasq实现DNS解锁" class="headerlink" title="使用Dnsmasq实现DNS解锁"></a>使用Dnsmasq实现DNS解锁</h4><p>该服务的原理是，使用Dnsmasq的DNS将网站解析劫持到SNI proxy反向代理的页面上。默认解锁Netflix/Hulu/HBO等流媒体，如需增删流媒体域名请编辑文件/etc/dnsmasq.d/custom_netflix.conf和/etc/sniproxy.conf，现以支持CentOS6/7， Debian8/9/10, Ubuntu16/18系统。</p><h5 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O dnsmasq_sniproxy.sh https://raw.githubusercontent.com/myxuchangbin/dnsmasq_sniproxy_install/master/dnsmasq_sniproxy.sh &amp;&amp; bash dnsmasq_sniproxy.sh -i</span><br></pre></td></tr></table></figure><h5 id="卸载方法："><a href="#卸载方法：" class="headerlink" title="卸载方法："></a>卸载方法：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O dnsmasq_sniproxy.sh https://raw.githubusercontent.com/myxuchangbin/dnsmasq_sniproxy_install/master/dnsmasq_sniproxy.sh &amp;&amp; bash dnsmasq_sniproxy.sh -u</span><br></pre></td></tr></table></figure><h5 id="DNS地址修改"><a href="#DNS地址修改" class="headerlink" title="DNS地址修改"></a>DNS地址修改</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/resolv.conf</span><br></pre></td></tr></table></figure><h5 id="调试排错"><a href="#调试排错" class="headerlink" title="调试排错"></a>调试排错</h5><ul><li><input checked="" disabled="" type="checkbox"> 确认sniproxy有效运行<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启sni命令:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果sni不在运行，可检查配置/etc/sniproxy.conf，避免nginx或者其他程序监听80,443，可将其配置文件的80更改为801等。 </span></span><br><span class="line"><span class="meta">#</span><span class="bash">443端口必须给sni监听放行，查看：netstat -tlunp|grep 443</span></span><br><span class="line">systemctl restart sniproxy</span><br></pre></td></tr></table></figure></li><li><input checked="" disabled="" type="checkbox"> 确认防火墙放行443,53端口<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">调试可直接关闭防火墙 </span></span><br><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure></li><li><input checked="" disabled="" type="checkbox"> 解析域名<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">配置完毕DNS后，解析域名，判断IP是否是NETFLIX代理机器IP。</span></span><br><span class="line">nslookup netflix.com</span><br><span class="line"><span class="meta">#</span><span class="bash">如果不存在nslookup命令，CENTOS安装：</span></span><br><span class="line">yum install -y bind-utils</span><br><span class="line"><span class="meta">#</span><span class="bash">DEBIAN安装：</span></span><br><span class="line">apt-get -y install dnsutils</span><br></pre></td></tr></table></figure></li></ul><p>相关工具:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RsdW5kcXVpc3Qvc25pcHJveHk=" title="https://github.com/dlundquist/sniproxy">HTTPS代理<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cDovL3d3dy50aGVrZWxsZXlzLm9yZy51ay9kbnNtYXNxL2RvYy5odG1s" title="http://www.thekelleys.org.uk/dnsmasq/doc.html">Dnsmasq<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RvcGljcy9jYWRkeXNlcnZlcg==" title="https://github.com/topics/caddyserver">Caddy<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
在谈论DNS流媒体解锁所需的SNI代理服务器之前，先来回顾和了解下通常情况下DNS请求发出之后的整个生命周期。首先，在客户端发出基于UDP协议53端口的DNS请求后，浏览器DNS缓存机制会率先寻找本地的缓存。假如未命中缓存则调用操作系统的getaddrinfo()系统函数，向操作系统寻求解析结果。倘若操作系统的DNS缓存依旧无法响应请求，则计算机向配置的上游DNS服务器发送请求，DNS服务器经历了递归和迭代之后，成功的将解析结果返回给设备的操作系统，随后向该IP发起HTTPS连接即可。
    
    </summary>
    
    
      <category term="网络" scheme="https://blog.kixcs.com/categories/network/"/>
    
    
      <category term="DNS" scheme="https://blog.kixcs.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin容器,泛型及高阶函数应用</title>
    <link href="https://blog.kixcs.com/archives/83a8/"/>
    <id>https://blog.kixcs.com/archives/83a8/</id>
    <published>2019-07-09T09:12:58.000Z</published>
    <updated>2020-03-09T09:43:10.676Z</updated>
    
    <content type="html"><![CDATA[<p>2011年7月，JetBrains推出Kotlin项目，这是一个面向JVM的新语言，它已被开发数年之久，它是一种在Java虚拟机上运行的静态类型编程语言，也可以被编译成为JavaScript源代码。它主要是由俄罗斯圣彼得堡的JetBrains开发团队所发展出来的编程语言，其名称来自于圣彼得堡附近的科特林岛。2012年1月，著名期刊《Dr. Dobb’s Journal》中它被认定为该月的最佳语言。虽然与Java语法并不兼容，但Kotlin被设计成可以和Java代码相互运作，并可以重复使用如Java集合框架等的现有Java引用的函数库。</p><p class="description"></p><a id="more"></a><h5 id="容器类型"><a href="#容器类型" class="headerlink" title="容器类型"></a>容器类型</h5><p>Kotlin号称全面兼容Java，于是乎Java的容器类仍可在Kotlin中正常使用，包括大家熟悉的队列ArrayList、映射HashMap等等。不过Kotlin作为一门全新的语言，肯定还是要有自己的容器类，不然哪天Java跟Kotlin划清界限，那麻烦就大了。与Java类似，Kotlin也拥有三类基本的容器，分别是集合Set、队列List、映射Map，然后每类容器又分作只读与可变两种类型，这是为了判断该容器能否进行增删改等变更操作。Kotlin对修改操作很慎重，比如变量用val前缀表示不可修改，用var前缀表示允许修改；类默认是不允许继承的，只有添加open前缀才允许该类被继承；至于容器默认为只读容器，如果需要进行修改则需加上Mutable形成新的容器，比如MutableSet表示可变集合，MutableList表示可变队列，MutableMap表示可变映射。<br>既然Set/List/Map都属于容器，那么必定拥有相同的基本容器方法，具体说明如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isEmpty() : 判断该容器是否为空。</span><br><span class="line">isNotEmpty() : 判断该容器是否非空。</span><br><span class="line">clear() : 清空该容器。</span><br><span class="line">contains() : 判断该容器是否包含指定元素。</span><br><span class="line">iterator() : 获取该容器的迭代器。</span><br><span class="line">count() : 获取该容器包含的元素个数，也可通过size属性获得元素数量。</span><br></pre></td></tr></table></figure><p>初始化赋值 : Kotlin允许在声明容器变量之时进行初始赋值，这点很方便比Java先进，当然不同容器的初始化方法有所区别，具体的对应关系见下表：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">名称:                  初始化方法:</span><br><span class="line">只读集合 Set           setOf()</span><br><span class="line">可变集合 MutableSet    mutableSetOf()</span><br><span class="line">只读队列 List          listOf()</span><br><span class="line">可变队列 MutableList   mutableListOf()</span><br><span class="line">只读映射 Map           mapOf()</span><br><span class="line">可变映射 MutableMap    mutableMapOf()</span><br></pre></td></tr></table></figure><p>以上是Kotlin容器的基本方法，更具体的增删改查等用法则有所不同，下面分别介绍这三类六种容器的详细用法。</p><h5 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h5><p>List是一种元素之间按照顺序排列的容器，它与集合的最大区别，便是多了个次序管理。正因为List建立了秩序规则，所以它比Set多提供了如下功能（注意凡是涉及到增删改的，都必须由MutableList来完成）：</p><ul><li><input checked="" disabled="" type="checkbox"> 队列的get方法能够获取指定位置的元素，也可直接通过下标获得该位置的元素。</li><li><input checked="" disabled="" type="checkbox"> MutableList的add方法每次都是把元素添加到队列末尾，也可指定添加的位置。</li><li><input checked="" disabled="" type="checkbox"> MutableList的set方法允许替换或者修改指定位置的元素。</li><li><input checked="" disabled="" type="checkbox"> MutableList的removeAt方法允许删除指定位置的元素。</li><li><input checked="" disabled="" type="checkbox"> MutableList提供了sort系列方法用于给队列中的元素重新排序，其中sortBy方法表示按照升序排列，sortByDescending方法表示按照降序排列。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空值判断</span></span><br><span class="line">List&lt;<span class="built_in">Int</span>&gt;?：List 本身可空，List 的元素不可空</span><br><span class="line">List&lt;<span class="built_in">Int</span>?&gt; ：List 本身不可空，List 的元素可空</span><br><span class="line">List&lt;<span class="built_in">Int</span>?&gt;? ：List 本身可空，List 的元素也可空</span><br></pre></td></tr></table></figure><p>对于List的遍历操作:for循环,迭代器循环,forEach循环,以及下标遍历。用法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"><span class="keyword">val</span> mylist:MutableList&lt;String&gt; = mutableListOf(<span class="string">"联想"</span>,<span class="string">"联想 Y520"</span>,<span class="string">"惠普"</span>,<span class="string">"戴尔"</span>,<span class="string">"IBM"</span>,<span class="string">"长城"</span>,<span class="string">"方正"</span>,<span class="string">"联想 Y720"</span>,<span class="string">"联想 Y7000"</span>);</span><br><span class="line">print(<span class="string">"电脑畅销榜已添加，当前共有<span class="subst">$&#123;mylist.size&#125;</span>款电脑\n"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"for-in 电脑畅销榜包含以下<span class="subst">$&#123;mylist.size&#125;</span>款电脑\n"</span>)</span><br><span class="line"><span class="keyword">for</span>(item <span class="keyword">in</span> mylist)&#123;</span><br><span class="line">print(<span class="string">"名称：<span class="subst">$&#123;item&#125;</span>\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第二个元素</span></span><br><span class="line"><span class="keyword">if</span>(mylist.size&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">mylist.removeAt(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">"removeAt电脑畅销榜已更新,当前包含以下<span class="subst">$&#123;mylist.size&#125;</span>款电脑\n"</span>)</span><br><span class="line">print(<span class="string">"for-in 电脑畅销榜包含以下<span class="subst">$&#123;mylist.size&#125;</span>款电脑\n"</span>)</span><br><span class="line"><span class="keyword">for</span>(item <span class="keyword">in</span> mylist)&#123;</span><br><span class="line">print(<span class="string">"名称：<span class="subst">$&#123;item&#125;</span>\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mylist.sortBy &#123; it.first() &#125;</span><br><span class="line">print(<span class="string">"for-in sort电脑畅销榜已按照it升序重新排列，包含以下<span class="subst">$&#123;mylist.size&#125;</span>款电脑\n"</span>)</span><br><span class="line"><span class="keyword">for</span>(item <span class="keyword">in</span> mylist)&#123;</span><br><span class="line">print(<span class="string">"名称：<span class="subst">$&#123;item&#125;</span>\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mylist.sortByDescending &#123; it.first() &#125;</span><br><span class="line">print(<span class="string">"for-in sort电脑畅销榜已按照it降序重新排列，包含以下<span class="subst">$&#123;mylist.size&#125;</span>款电脑\n"</span>)</span><br><span class="line"><span class="keyword">for</span>(item <span class="keyword">in</span> mylist)&#123;</span><br><span class="line">print(<span class="string">"名称：<span class="subst">$&#123;item&#125;</span>\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"iterator-while 电脑畅销榜包含以下<span class="subst">$&#123;mylist.size&#125;</span>款电脑\n"</span>)</span><br><span class="line"><span class="keyword">var</span> iter = mylist.iterator()</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">print(<span class="string">"名称：<span class="subst">$&#123;iter.next()&#125;</span>\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"foreach 电脑畅销榜包含以下<span class="subst">$&#123;mylist.size&#125;</span>款电脑\n"</span>)</span><br><span class="line">mylist.forEach &#123;</span><br><span class="line">print(<span class="string">"名称：<span class="subst">$&#123;it&#125;</span>\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"indices电脑畅销榜包含以下<span class="subst">$&#123;mylist.size&#125;</span>款电脑\n"</span>)</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> mylist.indices)&#123;</span><br><span class="line">print(<span class="string">"名称：<span class="subst">$&#123;mylist[i]&#125;</span>\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h5><p>Set集合是一种简单的容器，它具有以下特性：</p><ul><li><input checked="" disabled="" type="checkbox"> 容器内部的元素不按顺序排列，因此无法按照下标进行访问。</li><li><input checked="" disabled="" type="checkbox"> 容器内部的元素存在唯一性，通过哈希值校验是否存在相同的元素，如果存在则覆盖之；<br>因为Set是只读集合，初始化赋值后便不可更改，所以元素变更的方法只适用于可变集合MutableSet，但MutableSet的变更操作尚有以下限制。<ul><li><input checked="" disabled="" type="checkbox"> MutableSet的add方法仅仅往集合中添加元素，由于集合是无序的，因此不知道添加的具体位置。</li><li><input checked="" disabled="" type="checkbox"> MutableSet没有修改元素值的方法，一个元素一旦被添加，就不可被修改。</li><li><input checked="" disabled="" type="checkbox"> MutableSet的remove方法用于删除指定对象，但无法删除某个位置的元素，这是因为集合内的元素不是按顺序排列的。</li></ul></li></ul><p>对于Set的遍历操作:for循环,迭代器循环,forEach循环，三种循环遍历的用法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> goodsA:String=<span class="string">"惠普"</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> goodsB:String=<span class="string">"联想"</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> goodsC:String=<span class="string">"戴尔"</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> goodsD:String=<span class="string">"IBM"</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> goodsE:String=<span class="string">"长城"</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> goodsF:String=<span class="string">"方正"</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> myset:MutableSet&lt;String&gt; = mutableSetOf();</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">myset.add(goodsA)</span><br><span class="line">myset.add(goodsB)</span><br><span class="line">myset.add(goodsC)</span><br><span class="line">myset.add(goodsD)</span><br><span class="line">myset.add(goodsE)</span><br><span class="line">myset.add(goodsF)</span><br><span class="line">myset.remove(goodsA)</span><br><span class="line">print(<span class="string">"电脑畅销榜已添加，并且remove goodsA商品惠普，当前共有<span class="subst">$&#123;myset.size&#125;</span>款电脑\n"</span>)</span><br><span class="line">print(<span class="string">"for-in 电脑畅销榜包含以下<span class="subst">$&#123;myset.size&#125;</span>款电脑\n"</span>)</span><br><span class="line">print(<span class="string">"for-in测试\n"</span>)</span><br><span class="line"><span class="keyword">for</span>(item <span class="keyword">in</span> myset)&#123;</span><br><span class="line">print(item+<span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"iterator-while 电脑畅销榜包含以下<span class="subst">$&#123;myset.size&#125;</span>款电脑\n"</span>)</span><br><span class="line">print(<span class="string">"iterator测试\n"</span>)</span><br><span class="line"><span class="keyword">var</span> iter = myset.iterator()</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">print(iter.next()+<span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"foreach 电脑畅销榜包含以下<span class="subst">$&#123;myset.size&#125;</span>款电脑\n"</span>)</span><br><span class="line">print(<span class="string">"foreach测试\n"</span>)</span><br><span class="line">myset.forEach &#123;</span><br><span class="line">print(it+<span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"foreach\$拼接表达式电脑畅销榜包含以下<span class="subst">$&#123;myset.size&#125;</span>款电脑\n"</span>)</span><br><span class="line"><span class="keyword">var</span> dec=<span class="string">""</span></span><br><span class="line">myset.forEach &#123;</span><br><span class="line">dec=<span class="string">"<span class="subst">$&#123;dec&#125;</span>名称：<span class="subst">$&#123;it&#125;</span>\n"</span></span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">"<span class="variable">$dec</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Map类型"><a href="#Map类型" class="headerlink" title="Map类型"></a>Map类型</h5><p>映射内部保存的是一组键值对（Key-Value），也就是说，每个元素都由两部分构成，第一部分是元素的键，相当于元素的名字；第二部分是元素的值，存放着元素的详细信息。元素的键与值是一一对应的关系，相同的键名指向的值对象是唯一的，所以映射中每个元素的键名各不相同，这个特性使得映射的变更操作与队列存在以下不同之处（注意增删操作必须由MutableMap来完成）：</p><ul><li><input checked="" disabled="" type="checkbox"> 映射的containsKey方法判断是否存在指定键名的元素，containsValue方法判断是否存在指定值对象的元素。</li><li><input checked="" disabled="" type="checkbox"> 映射的containsKey方法判断是否存在指定键名的元素，containsValue方法判断是否存在指定值对象的元素；</li><li><input checked="" disabled="" type="checkbox"> MutableMap的put方法不单单是添加元素，而是智能的数据存储；每次调用put方法，映射会先根据键名寻找同名元素，如果找不到就添加新元素，如果找得到就用新元素替换旧元素；</li><li><input checked="" disabled="" type="checkbox"> MutableMap的remove方法，是通过键名来删除元素的；</li><li><input checked="" disabled="" type="checkbox"> 调用mapOf和mutableMapOf方法初始化映射之时，有两种方式可以表达单个键值对元素。其一是采取“键名 to 值对象”的形式，其二是采取Pair配对方式形如“Pair(键名, 值对象)”，下面是这两种初始化方式的代码例子：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//to方式初始化映射</span></span><br><span class="line"><span class="keyword">var</span> goodsMap = mapOf(<span class="string">"苹果"</span> to goodsA, <span class="string">"华为"</span> to goodsB, <span class="string">"小米"</span> to goodsC, <span class="string">"欧珀"</span> to goodsD, <span class="string">"步步高"</span> to goodsE, <span class="string">"魅族"</span> to goodsF)</span><br><span class="line"><span class="comment">//Pair方式初始化映射</span></span><br><span class="line"><span class="keyword">var</span> goodsMutMap = mutableMapOf(Pair(<span class="string">"苹果"</span>, goodsA), Pair(<span class="string">"华为"</span>, goodsB), Pair(<span class="string">"小米"</span>, goodsC), Pair(<span class="string">"欧珀"</span>, goodsD), Pair(<span class="string">"步步高"</span>, goodsE), Pair(<span class="string">"魅族"</span>, goodsF))</span><br><span class="line"></span><br><span class="line">遍历方式与Set相似，如下</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> goodsMutMap=mutableMapOf&lt;String, String&gt;(Pair(<span class="string">"苹果"</span>, goodsA),Pair(<span class="string">"华为"</span>, goodsB),Pair(<span class="string">"戴尔"</span>, goodsC),Pair(<span class="string">"华硕"</span>, goodsD),Pair(<span class="string">"弘基"</span>,goodsE),Pair(<span class="string">"联想"</span>, goodsE));</span><br><span class="line"><span class="keyword">for</span>(item <span class="keyword">in</span> goodsMutMap)&#123;</span><br><span class="line">print(<span class="string">"厂家：<span class="subst">$&#123;item.key&#125;</span>，名称：<span class="subst">$&#123;item.value&#125;</span>\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器循环</span></span><br><span class="line"><span class="keyword">var</span> iterator= goodsMutMap.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line"><span class="keyword">var</span> item=iterator.next();</span><br><span class="line">print(<span class="string">"厂家：<span class="subst">$&#123;item.key&#125;</span>名称：<span class="subst">$&#123;item.value&#125;</span>\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for each循环</span></span><br><span class="line">goodsMutMap.forEach&#123;</span><br><span class="line">print(<span class="string">"厂家：<span class="subst">$&#123;it.key&#125;</span>，名称：<span class="subst">$&#123;it.value&#125;</span>\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h5><p>泛型的引入：函数的输入参数类型必须在定义函数时就要指定，可是有时候参数类型是不确定的，只有在函数调用时方能知晓具体类型，如此一来要怎样声明函数呢？<br>定义泛型函数时，得在函数名称前面添加“<T>”，表示以T声明的参数（包括输入参数和输出参数），其参数类型必须在函数调用时指定。<br>实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">appendString</span><span class="params">(tag:<span class="type">String</span>, <span class="keyword">var</span> otherInfo:<span class="type">T</span>?)</span></span>:String&#123;</span><br><span class="line"><span class="keyword">var</span> str:String = <span class="string">"<span class="variable">$tag</span>:"</span></span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> otherInfo)&#123;</span><br><span class="line">str=<span class="string">"<span class="variable">$str</span><span class="subst">$&#123;item.toString()&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">when</span>(count%<span class="number">3</span>)&#123;</span><br><span class="line"><span class="number">0</span> -&gt; appendString&lt;String&gt;(<span class="string">"古代的四大发明"</span>,<span class="string">"造纸术"</span>,<span class="string">"印刷术"</span>,<span class="string">"火药"</span>,<span class="string">"指南针"</span>)</span><br><span class="line"><span class="number">1</span> -&gt; appendString&lt;<span class="built_in">Int</span>&gt;(<span class="string">"小于10的素数"</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>)</span><br><span class="line"><span class="keyword">else</span> -&gt; appendString&lt;<span class="built_in">Double</span>&gt;(<span class="string">"烧钱的日子"</span>,<span class="number">5.20</span>,<span class="number">6.18</span>,<span class="number">11.11</span>,<span class="number">12.12</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h5><p>注意到前面定义泛型函数appendString，是把它作为一个全局函数，也就是在类外面定义，不在类内部定义。因为类的成员函数依赖于类，只有泛型类（又称模板类）才能拥有成员泛型函数，普通类是不允许定义泛型函数的，否则编译器会直接报错。不过有个例外情况，如果参数类型都是继承自某种类型，那么允许在定义函数时指定从这个基类泛化开，凡是继承自该基类的子类，都可以作为输入参数进行函数调用，反之则无法调用函数。<br>举个例子，Int、Float和Double都继承自Number，但是定义一个setArrayNumber(array:Array<Number>)函数，它并不接受Array<Int>或者Array<Double>的入参，如果要让该方法同时接受源自Number的数组入参，就得定义泛化自Number的泛型函数，即将<T>改为<reified T : Number>，同时在fun前面添加关键字inline，表示该函数也为内联函数。内联函数在编译之时，会在调用处把该函数的内部代码直接复制一份，调用十次就会复制十份，而非普通函数那样仅仅提供一个函数的访问地址。该例子的函数定义代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数不接受Array&lt;Int&gt;，也不接受Array&lt;Double&gt;，只好沦为孤家寡人</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setArrayNumber</span><span class="params">(array:<span class="type">Array</span>&lt;<span class="type">Number</span>&gt;)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> str:String = <span class="string">"数组元素依次排列："</span></span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> array) &#123;</span><br><span class="line">str = str + item.toString() + <span class="string">", "</span></span><br><span class="line">&#125;</span><br><span class="line">tv_function_result.text = str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有内联函数才可以被具体化</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : Number&gt;</span> <span class="title">setArrayStr</span><span class="params">(array:<span class="type">Array</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> str:String = <span class="string">"数组元素依次排列："</span></span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> array) &#123;</span><br><span class="line">str = str + item.toString() + <span class="string">", "</span></span><br><span class="line">&#125;</span><br><span class="line">tv_function_result.text = str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h5><p>系统自带的类已经提供了许多方法，然而经常还是无法完全满足业务需求，此时开发者往往要写个工具类，比如StringUtil、DateUtil之类，来补充相关的处理功能，长此以往，工具类越来越多也越来越难以管理。<br>基于以上情况，Kotlin推出了扩展函数的概念，允许开发者给系统类补写新的方法，而无需另外编写额外的工具类。比如系统自带的数组Array提供了求最大值的max方法，提供了进行排序的sort方法，可是并未提供交换数组元素的方法。于是我们打算给Array增加新的交换方法，也就是添加一个扩展函数swap，与众不同的是要在函数名称前面加上“Array<Int>.”，表示该函数扩展自Array<Int>。swap函数的定义代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Array<span class="type">&lt;Int&gt;</span>.<span class="title">swap</span><span class="params">(pos1:<span class="type">Int</span>, pos2:<span class="type">Int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">val</span> temp = <span class="keyword">this</span>[pos1]</span><br><span class="line"><span class="keyword">this</span>[pos1] = <span class="keyword">this</span>[pos2]</span><br><span class="line"><span class="keyword">this</span>[pos2] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与泛型函数结合可以增强它的泛用性</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;T&gt;</span>.<span class="title">swap</span><span class="params">(pos1:<span class="type">Int</span>, pos2:<span class="type">Int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">val</span> temp = <span class="keyword">this</span>[pos1]</span><br><span class="line"><span class="keyword">this</span>[pos1] = <span class="keyword">this</span>[pos2]</span><br><span class="line"><span class="keyword">this</span>[pos2] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例：消除重复元素</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span>  city :MutableList&lt;String&gt; = mutableListOf( <span class="string">"Shanghai Job Offered"</span>, <span class="string">"Beijing Events"</span>, <span class="string">"Beijing Language"</span>,<span class="string">"Beijing Massage &amp; Escort"</span> ,<span class="string">"Beijing Language"</span>,<span class="string">"Beijing Events"</span>,<span class="string">"Shanghai Job Offered"</span>)</span><br><span class="line"><span class="keyword">var</span>  testNum :MutableList&lt;<span class="built_in">Int</span>&gt; = mutableListOf( <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">testNum.sort()</span><br><span class="line"><span class="keyword">for</span>(item <span class="keyword">in</span> testNum.deleteDuplication())&#123;</span><br><span class="line">println(<span class="string">"<span class="variable">$item</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">city.sort()</span><br><span class="line"><span class="keyword">for</span>(item <span class="keyword">in</span> city.deleteDuplication())&#123;</span><br><span class="line">println(<span class="string">"<span class="variable">$item</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新建辅助数组</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> MutableList<span class="type">&lt;T&gt;</span>.<span class="title">deleteDuplication</span><span class="params">()</span></span>:MutableList&lt;T&gt;&#123;</span><br><span class="line"><span class="keyword">var</span> res:MutableList&lt;T&gt; = mutableListOf()</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="keyword">this</span>.indices)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; <span class="keyword">this</span>[i]==<span class="keyword">this</span>[i-<span class="number">1</span>]) <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">else</span> res.add(<span class="keyword">this</span>[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="尾递归函数"><a href="#尾递归函数" class="headerlink" title="尾递归函数"></a>尾递归函数</h5><p>Kotlin引入了扩展函数，还能反过来精简函数。具体地说，如果一个函数的表达式比较简单，一两行就可以搞定的话，Kotlin允许使用等号代替大括号。<br>例如：5!=5<em>4</em>3<em>2</em>1</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">factorial</span><span class="params">(n:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>) n</span><br><span class="line"><span class="keyword">else</span> n*factorial(n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以简化成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">factorial</span><span class="params">(n:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span> = <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) n <span class="keyword">else</span> n*factorial(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>Kotlin体系还存在一种特殊的递归函数，名叫尾递归函数，它指的是函数末尾的返回值重复调用了自身函数。此时要在fun前面加上关键字tailrec，告诉编译器这是个尾递归函数，则编译器会相应进行优化，从而提高程序性能。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果函数尾部递归调用自身，则可加上关键字tailrec表示这是个尾递归函数，</span></span><br><span class="line"><span class="comment">//此时编译器会自动优化递归，即用循环方式代替递归，从而避免栈溢出的情况。</span></span><br><span class="line"><span class="comment">//比如下面这个求余弦不动点的函数就是尾递归函数</span></span><br><span class="line"><span class="comment">//实例:</span></span><br><span class="line"><span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">findFixPoint</span><span class="params">(x: <span class="type">Double</span> = <span class="number">1.0</span>)</span></span>: <span class="built_in">Double</span></span><br><span class="line">= <span class="keyword">if</span> (x == Math.cos(x)) x <span class="keyword">else</span> findFixPoint(Math.cos(x))</span><br></pre></td></tr></table></figure><h5 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h5><p>前面多次提到函数被Kotlin当作特殊变量，包括函数声明采取跟变量声明一样的形式“名称:类型”，以及简化函数允许直接用等号连接函数体等等，那么本节最后讲述的则是把A函数作为B函数的输入参数，就像普通变量一样参与B函数的表达式计算。此时因为B函数的入参内嵌了A函数，故而B函数被称作高阶函数，对应的A函数则为低阶函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="comment">//允许将函数表达式作为输入参数传进来，就形成了高阶函数，这里的greater函数就像是个变量</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">maxCustom</span><span class="params">(array: <span class="type">Array</span>&lt;<span class="type">T</span>&gt;, greater: (<span class="type">T</span>, <span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: T? &#123;</span><br><span class="line"><span class="keyword">var</span> max: T? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> array)</span><br><span class="line"><span class="keyword">if</span> (max == <span class="literal">null</span> || greater(item, max))</span><br><span class="line">max = item</span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> string_array:Array&lt;String&gt; = arrayOf(<span class="string">"How"</span>, <span class="string">"do"</span>, <span class="string">"you"</span>, <span class="string">"do"</span>, <span class="string">"I'm   "</span>, <span class="string">"Fine"</span>)</span><br><span class="line">println(<span class="string">"字符串数组的默认最大值为<span class="subst">$&#123;string_array.max()&#125;</span>"</span>)</span><br><span class="line"><span class="comment">//因为高阶函数maxCustom同时也是泛型函数，所以要在函数名称后面加上&lt;String&gt;</span></span><br><span class="line">println(<span class="string">"字符串数组按长度比较的最大值为<span class="subst">$&#123;maxCustom&lt;String&gt;(string_array, &#123; a, b -&gt; a.length &gt; b.length &#125;</span>)&#125;"</span>)</span><br><span class="line"><span class="comment">//string_array.max()对应的高阶函数是maxCustom(string_array, &#123; a, b -&gt; a &gt; b &#125;)</span></span><br><span class="line">println(<span class="string">"字符串数组的默认最大值(使用高阶函数)为<span class="subst">$&#123;maxCustom(string_array, &#123; a, b -&gt; a &gt; b &#125;</span>)&#125;"</span>)</span><br><span class="line"><span class="comment">//因为系统可以根据string_array判断泛型函数采用了String类型，故而函数名称后面的&lt;String&gt;也可以省略掉</span></span><br><span class="line">println(<span class="string">"字符串数组按去掉空格再比较长度的最大值为<span class="subst">$&#123;maxCustom(string_array, &#123; a, b -&gt; a.trim().length &gt; b.trim().length &#125;</span>)&#125;"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前述的高阶函数maxCustom同时结合了泛型函数的写法，其实还可以给它加上扩展函数的功能。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;T&gt;</span>.<span class="title">maxCustom</span><span class="params">(array: <span class="type">Array</span>&lt;<span class="type">T</span>&gt;, greater: (<span class="type">T</span>, <span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: T? &#123;</span><br><span class="line"><span class="keyword">var</span> max: T? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> array)</span><br><span class="line"><span class="keyword">if</span> (max == <span class="literal">null</span> || greater(item, max))</span><br><span class="line">max = item</span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，感谢好朋友的分享:) <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29uZXBpZWNlX2xvdmVzL2FydGljbGUvZGV0YWlscy85MzIwNDA2Mg==" title="https://blog.csdn.net/onepiece_loves/article/details/93204062">Kotlin学习笔记 By Soul丶Knight<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2011年7月，JetBrains推出Kotlin项目，这是一个面向JVM的新语言，它已被开发数年之久，它是一种在Java虚拟机上运行的静态类型编程语言，也可以被编译成为JavaScript源代码。它主要是由俄罗斯圣彼得堡的JetBrains开发团队所发展出来的编程语言，其名称来自于圣彼得堡附近的科特林岛。2012年1月，著名期刊《Dr. Dobb’s Journal》中它被认定为该月的最佳语言。虽然与Java语法并不兼容，但Kotlin被设计成可以和Java代码相互运作，并可以重复使用如Java集合框架等的现有Java引用的函数库。&lt;/p&gt;
&lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.kixcs.com/categories/technique/"/>
    
    
      <category term="Kotlin" scheme="https://blog.kixcs.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7使用Fail2Ban保护SSH</title>
    <link href="https://blog.kixcs.com/archives/ee68/"/>
    <id>https://blog.kixcs.com/archives/ee68/</id>
    <published>2018-07-15T09:31:06.000Z</published>
    <updated>2020-03-13T09:51:22.856Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p>Fail2ban是一款入侵防御软件，可以保护服务器免受暴力攻击。Fail2ban 基于 auth 日志文件工作，默认情况下它会扫描所有 auth 日志文件，如/var/log/auth.log等，并禁止带有恶意标志的 IP，如密码尝试次数过多等。Fail2ban 由 Python 编写而成，主要配合 iptables 来进行工作，为各种服务提供了过滤器，如 SSH、Apache、Nginx、Squid、Named、Mysql、Nagios 等。Fail2ban 能够降低风险，但不能消除风险，这只是服务器防止暴力攻击的安全手段之一，本文以CentOS为例。<a id="more"></a><h4 id="安装Fail2ban"><a href="#安装Fail2ban" class="headerlink" title="安装Fail2ban"></a>安装Fail2ban</h4><p>Fail2ban不在官方软件包仓库中，它在EPEL中（Extra Packages for Enterprise Linux）。<br>安装epel-release：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br></pre></td></tr></table></figure><p>由于 Fail2ban 依赖于 Python，需要确保 Python 版本 ≥ 2.6：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -V</span><br></pre></td></tr></table></figure><p>安装Fail2ban：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install fail2ban</span><br></pre></td></tr></table></figure><p>安装完成之后，启用Fail2ban：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable fail2ban</span><br></pre></td></tr></table></figure><h4 id="文件目录结构"><a href="#文件目录结构" class="headerlink" title="文件目录结构"></a>文件目录结构</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/fail2ban               ## fail2ban 服务配置目录</span><br><span class="line">/etc/fail2ban/action.d      ## iptables 、mail 等动作文件目录</span><br><span class="line">/etc/fail2ban/filter.d      ## 条件匹配文件目录，过滤日志关键内容</span><br><span class="line">/etc/fail2ban/jail.conf     ## fail2ban 防护配置文件</span><br><span class="line">/etc/fail2ban/fail2ban.conf ## fail2ban 配置文件，定义日志级别、日志、sock 文件位置等</span><br></pre></td></tr></table></figure><h4 id="配置Fail2ban"><a href="#配置Fail2ban" class="headerlink" title="配置Fail2ban"></a>配置Fail2ban</h4><p>Fail2ban服务的配置文件在/etc/fail2ban目录。在其中可以找到jail.conf配置文件，官方的文档写到：在配置时，我们应该避免修改由fail2ban安装创建的文件，我们应该去编写具有.local扩展名的新文件,因为在升级软件包时，会覆盖这个文件，使配置失效。当我们的配置发生改变了我们可以使用 fail2ban-client reload ，来加载新的配置。我们应该创建一个新文件jail.local，在jail.local定义的值会覆盖jail.conf中的值。<br>我们来创建一个jail.local文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fail2ban/jail.local</span><br></pre></td></tr></table></figure><p>或者:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fail2ban/jail.d/jail.local</span><br></pre></td></tr></table></figure><p>写入如下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">defalut这里是设定全局设置，如果下面的监控没有设置就以全局设置的值设置。</span></span><br><span class="line">[DEFAULT]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用于指定哪些地址ip可以忽略 fail2ban 防御,以空格间隔。</span></span><br><span class="line">ignoreip = 127.0.0.1/8</span><br><span class="line"><span class="meta">#</span><span class="bash"> 客户端主机被禁止的时长（默认单位为秒）</span></span><br><span class="line">bantime  = 3600</span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤的时长（秒）</span></span><br><span class="line">findtime  = 600</span><br><span class="line"><span class="meta">#</span><span class="bash"> 匹配到的阈值（次数）</span></span><br><span class="line">maxretry = 3</span><br><span class="line"></span><br><span class="line">[ssh-iptables]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否开启</span></span><br><span class="line">enabled  = true</span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤规则</span></span><br><span class="line">filter   = sshd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 动作</span></span><br><span class="line">action   = iptables[name=SSH, port=ssh, protocol=tcp]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志文件的路径</span></span><br><span class="line">logpath  = /var/log/secure</span><br><span class="line"><span class="meta">#</span><span class="bash"> 匹配到的阈值（次数）</span></span><br><span class="line">maxretry = 3</span><br></pre></td></tr></table></figure><p>在上面配置好了之后，我们需要让配置生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fail2ban-client reload</span><br></pre></td></tr></table></figure><p>配置完成之后，重启fail2ban：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart fail2ban</span><br></pre></td></tr></table></figure><p>或者:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service fail2ban restart</span><br></pre></td></tr></table></figure><p>查看登录失败的记录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lastb</span><br></pre></td></tr></table></figure><p>查询fail2ban服务状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fail2ban-client status</span><br></pre></td></tr></table></figure><p>查询某个jail的详细信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fail2ban-client status ssh-iptables</span><br></pre></td></tr></table></figure><p>实用命令<br>最近一次启动，fail2ban日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -b -u fail2ban</span><br></pre></td></tr></table></figure><p>实时跟踪显示fail2ban日志（按Ctrl-C退出）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -F /var/log/fail2ban.log</span><br></pre></td></tr></table></figure><p>显示防火墙规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -L</span><br></pre></td></tr></table></figure><p>显示防火墙规则对应的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -S</span><br></pre></td></tr></table></figure><p>fail2ban从黑名单（ban list）中移除IP的方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fail2ban-client set ssh-iptables  unbanip 1.1.1.1</span><br></pre></td></tr></table></figure><p>此时再查看banlist会发现IP已移除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fail2ban-client status ssh-iptables </span><br></pre></td></tr></table></figure><p>跟踪失败的登录条目:<br>以下命令用于检查是否通过ssh端口尝试登录服务器失败。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/secure | grep 'Failed password'</span><br></pre></td></tr></table></figure><p>执行上述命令将得到来自不同IP地址的根密码尝试失败的列表。 结果的格式与下面所示的相似：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Fer 8 12:41:12 htf sshd[5487]: Failed password for root from 1.1.1.1 port 23021 ssh2</span><br><span class="line">Fer 8 12:41:15 htf sshd[1254]: Failed password for root from 1.1.1.1 port 15486 ssh2</span><br><span class="line">Fer 8 12:41:16 htf sshd[1254]: Failed password for root from 1.1.1.1 port 24457 ssh2</span><br><span class="line">Fer 8 12:41:18 htf sshd[1254]: Failed password for root from 1.1.1.1 port 24457 ssh2</span><br></pre></td></tr></table></figure><p>通过Fail2Ban检查被禁止的IP:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -L -n</span><br></pre></td></tr></table></figure><p>查看当前被禁止登陆的ip：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[root@121]#</span><span class="bash"> fail2ban-client status ssh-iptables </span></span><br><span class="line">Status for the jail: ssh-iptables</span><br><span class="line">|- filter</span><br><span class="line">|  |- File list:    /var/log/secure     #日志文件路径</span><br><span class="line">|  |- Currently failed:    0        #当前失败次数</span><br><span class="line">|  `- Total failed:    3            #总失败次数</span><br><span class="line">`- action</span><br><span class="line">   |- Currently banned:    1        #当前禁止的ip数量</span><br><span class="line">   |  `- IP list:    192.168.1.112        #当前禁止的ip</span><br><span class="line">   `- Total banned:    1        #禁止的ip总数</span><br></pre></td></tr></table></figure><p>启动暂停查看状态:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start/restart/stop/status fail2ban</span><br></pre></td></tr></table></figure><p>fail2ban-regex测试筛选规则设否匹配当前的日志格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fail2ban-regex /var/log/secure  /etc/fail2ban/filter.d/sshd.conf</span><br></pre></td></tr></table></figure><h4 id="fail2ban-conf配置文件"><a href="#fail2ban-conf配置文件" class="headerlink" title="fail2ban.conf配置文件"></a>fail2ban.conf配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shell &gt; grep -v ^# /etc/fail2ban/fail2ban.conf</span><br><span class="line"> </span><br><span class="line">[Definition]</span><br><span class="line">loglevel = 3                              ## 定义日志级别，默认</span><br><span class="line">logtarget = /var/log/fail2ban.log         ## 定义 fail2ban 日志文件</span><br><span class="line">socket = /var/run/fail2ban/fail2ban.sock  ## sock 文件存放位置，默认</span><br><span class="line">pidfile = /var/run/fail2ban/fail2ban.pid  ## pid 文件存放位置，默认</span><br></pre></td></tr></table></figure><h4 id="jail-conf-防护配置"><a href="#jail-conf-防护配置" class="headerlink" title="jail.conf 防护配置"></a>jail.conf 防护配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">shell &gt; grep -v ^# /etc/fail2ban/jail.conf</span><br><span class="line"></span><br><span class="line">[DEFAULT]                         ## 全局设置，优先级最小</span><br><span class="line">ignoreip = 127.0.0.1/8            ## 不受限制的 IP ，多组用空格分割</span><br><span class="line">bantime = 600                     ## 非法 IP 被屏蔽时间（秒），-1 代表永远封锁</span><br><span class="line">findtime = 600                    ## 设置多长时间（秒）内超过 maxretry 限制次数即被封锁</span><br><span class="line">maxretry = 3                      ## 最大尝试次数</span><br><span class="line">backend = auto                    ## 日志修改检测机制（gamin 、polling 、auto 三种）</span><br><span class="line">usedns = warn</span><br><span class="line">[ssh-iptables]                    ## 分类设置（基于 SSHD 服务的防护）</span><br><span class="line">enabled = true                    ## 是否开启防护，false 为关闭</span><br><span class="line">filter = sshd                     ## 过滤规则 filter 名称，对应 filter.d 目录下的 sshd.conf</span><br><span class="line">action = iptables[name=SSH, port=ssh, protocol=tcp] ## 动作参数 </span><br><span class="line">logpath = /var/log/secure         ## 检测系统登陆日志文件</span><br><span class="line">maxretry = 5                      ## 最大尝试次数</span><br></pre></td></tr></table></figure><h4 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h4><p>修改端口问题:sshd更改端口号后使用fail2ban需要注意在填写配置的时候也需要更改端口号。否则会出现就算会将ip添加到防火墙，但由于变更了SSH端口号，是起不到禁止作用的。<br>解决方法：配置文件中 action = iptables[name=SSH, port=ssh, protocol=tcp] ,port位置修改为新的端口。</p>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;
Fail2ban是一款入侵防御软件，可以保护服务器免受暴力攻击。Fail2ban 基于 auth 日志文件工作，默认情况下它会扫描所有 auth 日志文件，如/var/log/auth.log等，并禁止带有恶意标志的 IP，如密码尝试次数过多等。
Fail2ban 由 Python 编写而成，主要配合 iptables 来进行工作，为各种服务提供了过滤器，如 SSH、Apache、Nginx、Squid、Named、Mysql、Nagios 等。Fail2ban 能够降低风险，但不能消除风险，这只是服务器防止暴力攻击的安全手段之一，本文以CentOS为例。
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.kixcs.com/categories/technique/"/>
    
    
      <category term="SSH" scheme="https://blog.kixcs.com/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://blog.kixcs.com/archives/24c0/"/>
    <id>https://blog.kixcs.com/archives/24c0/</id>
    <published>2018-04-11T12:48:37.000Z</published>
    <updated>2020-03-01T11:58:09.081Z</updated>
    
    <content type="html"><![CDATA[<p class="description">Hexo是一个快速、简洁且高效的博客框架，其构建依托于Node.js（Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎）；Hexo同时支持 Markdown，支持GitHub Flavored Markdown的所有功能，甚至可以整合Octopress的大多数插件，只需一条指令即可部署到 GitHub Pages, Heroku 或其他平台，除此之外，它拥有丰富的插件和可扩展性，其强大的 API 带来无限的可能，可与数种模板引擎（EJS，Pug，Nunjucks）和工具（Babel，PostCSS，Less/Sass）轻易集成。</p><a id="more"></a><p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==" title="https://hexo.io/">Hexo<i class="fa fa-external-link"></i></span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv" title="https://hexo.io/docs/">documentation<i class="fa fa-external-link"></i></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=" title="https://hexo.io/docs/troubleshooting.html">troubleshooting<i class="fa fa-external-link"></i></span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==" title="https://github.com/hexojs/hexo/issues">GitHub<i class="fa fa-external-link"></i></span>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s" title="https://hexo.io/docs/writing.html">Writing<i class="fa fa-external-link"></i></span></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=" title="https://hexo.io/docs/server.html">Server<i class="fa fa-external-link"></i></span></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s" title="https://hexo.io/docs/generating.html">Generating<i class="fa fa-external-link"></i></span></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s" title="https://hexo.io/docs/one-command-deployment.html">Deployment<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;
Hexo是一个快速、简洁且高效的博客框架，其构建依托于Node.js（Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎）；Hexo同时支持 Markdown，支持GitHub Flavored Markdown的所有功能，甚至可以整合Octopress的大多数插件，只需一条指令即可部署到 GitHub Pages, Heroku 或其他平台，除此之外，它拥有丰富的插件和可扩展性，其强大的 API 带来无限的可能，可与数种模板引擎（EJS，Pug，Nunjucks）和工具（Babel，PostCSS，Less/Sass）轻易集成。
&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://blog.kixcs.com/categories/technique/"/>
    
    
      <category term="Hexo" scheme="https://blog.kixcs.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>关于计算机系统安全的若干问题及解决方案</title>
    <link href="https://blog.kixcs.com/archives/38d9/"/>
    <id>https://blog.kixcs.com/archives/38d9/</id>
    <published>2017-01-25T11:51:14.000Z</published>
    <updated>2020-03-01T12:01:31.270Z</updated>
    
    <content type="html"><![CDATA[<p class="description">2013年6月，前美国中央情报局技术分析员，爱德华.斯诺登将美国“棱镜”电子监听计划披露给英国《卫报》记者格伦·格林沃尔德。如今，有越来越多的证据显示，个人电子邮件，浏览信息，聊天记录，网站信息正在被大规模的监控。从斯诺登曝光的机密文件可看出，NAS（美国国家安全局）不仅通过网络远程监控，还通过“人力情报”项目的方式挖取个人隐私。人们有必要去采取必要手段来抑制有关机构这种不正当的行径，从而维护公民基本合法权益。</p><a id="more"></a><h4 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h4><p>近年来，为应对信息全球化，美国Microsoft公司在数十年时间内锐意进取，Windows平台不断推陈出新。近年来，微软一贯采取率先发布预览版，采集用户反馈信息的方式去修复系统与应用软件不兼容问题，或是采取不定期发布系统安全补丁的方式来维持用户良好的操作环境。</p><p>截止到2016年5月25日，Windows操作系统占中国大陆比重高达79.96％。近年来，盗版微软系统在国内猖獗，早在Windows XP时代，国内用户普遍采取使用ISO镜像文件安装Ghost盗版系统，上至知名PC品牌售后服务中心，下至城镇电脑维修点，莫不如此。众所周知，制造者可使用UltraISO等软件编译指定的ISO文件，因此，安装未知来源的镜像系统存才不可忽视的安全风险。</p><p>伴随操作系统应运而生的是WinPE维护系统，在方便用户进行系统主引导区修复，还原和备份系统分区等操作的同时，紧随而来的安全问题也同样令人堪忧。例如，用户可以在硬件尚未自检，系统尚未启动的BIOS（CMOS）界面下，更改计算机的第一启动顺序为外部储存器（例如闪存盘或是移动硬盘），从而启动WinPE。在当前的维护系统界面中，市面上主流的PE系统（U深度，老毛桃，大白菜，一件工作室等）普遍内置了，例如ADSL账号密码获取工具，开机密码移除和账户添加工具等等。在方便用户对系统做出更改的同时，也给予不法分子以可乘之机。</p><p>例如，Windows操作系统中，与登录密码相关联的是主分区目录下的SAM文件,WinPE内置的工具中，可以指定访问C:\Windows\System32\Config\sam路径下的数据库文件。本人亲测，一方面，除微软账户登录选项的密码外，其他类型账户（包括Administrator账户），可以做到强制更改。另一方面，倘若只有微软账户登录选型，他人可以通过解锁Administrator账户，并且具有系统最高权限（众所周知，初始状态的Administrator账户是无密码）或是解锁Default Account，或是解锁Guest User账户来实现系统的访问。更有甚者，在更低版本的Windows系统中，例如Win7,Vista,WinXP，他人甚至无需登录WinPE系统就可以实现对SAM文件的修改。由此可见，老系统固然性能稳定，兼容性良好，但因存在市场时间太久，会暴露出有待改进的地方。</p><p>倘若不使用WinPE系统对开机密码做出修改，还可以通过命令提示符语句实现上述操作，具体步骤如下：假设当前使用的计算机主板的启动方式为UEFI，而不是慢慢退出市场的传统BIOS启动方式，则需要另做更改。开机按下F2键（不同品牌主板按键略有差异）不动，在“Boot”标签下，更改UEFI为Legacy Support，此时会有Legacy First字样，F10保存并退出。倘若可以正常进入系统，在管理员模式下运行命令提示符，输入“bcdedit /set {default} bootmenupolicy legacy”带系统显示:操作完成字样后退出即可。上述命令语句为实现安全模式的快速启动，按下F8即可进入。或是点下Shift选择重启即可一次性进入安全模式。或是倘若无法正常进入系统，要实现对安全模式的访问，若是笔记本电脑，在开机界面强制关机4~5次即可，若是台式计算机，用户可直接拔下电源，下次开机计算机会自动进入安全模式（注：上述方法会对计算机硬件造成不可逆损伤）。用户进入安全模式，在“疑难解惑”标签下选择“带有命令提示符的安全模式”。在对话框中输入“net user setName password /add”(注：setName为自定义用户名，password为自定义密码)即可实现对系统账户的添加（此账户不具管理员权限）。倘若要赋予该用户管理员权限，进入命令提示符，输入“net localgroup administrators setName”，即可将用户提升为系统管理组的用户，进而拥有最高权限。（注：本人亲测，在WinPE环境下运行命令提示符，上述操作无效。系统将显示“无法识别net关键字”从而无法执行命令语句）。当上述操作进行完毕，即可实现对并行账户的设置。值得说明的是，PIN码最初目的是：方便识别用户，快速登录系统，然而，它的级别实际上是低于密码的，用户可以强制更改密码，无需验证即可删除PIN码，或是在“登录选项”中选择重设的密码登录，进而窃取用户数据。总而言之，Windows密码只能在安全层面起到一定的阻拦作用，并不能完全规避风险。可见，大多数用户所使用的计算机并不如官方宣称那般固若金汤。</p><p>针对上述存在的安全风险，解决方案如下：</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><h6 id="一：驱动器加密方式"><a href="#一：驱动器加密方式" class="headerlink" title="一：驱动器加密方式"></a>一：驱动器加密方式</h6><p>针对Windows平台，用户可以使用Windows自身的驱动器加密功能：BitLocker。Windows Vista首次推出，Windows 7进行了完善，Win8,Win8.1,Win10进行了很好的继承。（编者注：Windows10专业版及其以上版本包含此功能，且设备支持TPM模块）BitLocker在Win10平台存在两种加密模式，兼容模式和快速模式。顾名思义，兼容模式可以使驱动器在更老的系统上运行，但存在弊病：加密速度迟缓且安全等级不高（本人亲测，针对西部数据1TB移动硬盘选择兼容模式，加密时间长达10小时，连续长时间的20MB/s的写入写出操作将给硬盘碟片造成不可逆损伤）。选择快速模式，则采用AES 128bit的加密方式。（截至目前为止，AES 256位加密方式对中国的技术出口被美国军方所限制，因此，大陆地区非商业用途最高为128位AES加密方式）只要用户设置的密码足够复杂，在现阶段量子计算机正处于研发阶段并未投入商业化的情况下，可以近似认为该加密方式完美。在设置驱动器密码短语结束后，用户应妥善保存48位的数字恢复秘钥并与之对应的标识符。（针对美国政府的“秘钥收集”计划，建议用户最好不选择保存在微软OneDrive云服务器，或是苹果iCloud云服务器上。）倘若用户希望针对系统分区进行驱动器加密，并设置硬件层面的安全保护。打开命令提示符并执行如下命令：“manage-bde -protectors -add c: -TPMAndStartupKey h”（注：h为外部储存介质的盘符）从而将.bek系统文件转移至外部储存介质，每次开机时，用户须插入指定U盘才可解锁系统。</p><h6 id="二：局部加密方式"><a href="#二：局部加密方式" class="headerlink" title="二：局部加密方式"></a>二：局部加密方式</h6><p>PGP(Pretty Good Privacy)，美国赛门铁克公司的安全软件，最高支持AES256位加密方式，支持构建PGP压缩包，虚拟分区，加密邮件等功能。用户可以自定义秘钥，用于新建虚拟磁盘或是加密整个驱动器或分区。2013年爱德华.斯诺登正是使用该软件，向英国《卫报》记者通过加密邮件提供了大量信息。在使用过程中，功能强悍的同时，操作较为麻烦。（本人亲测，PGP Desktop 10.2.0版本中，存在在U盘中加载虚拟分区后，USB设备存在无法正常弹出情况）。该软件截至目前为止，官方尚未发布简体中文版，用户需自行汉化（将汉化文件夹下所有文件覆盖粘贴至“String”文件目录下）。使用顺序最好为破解后汉化。本人注册机字样提供：</p><p>(附录：Name: Team ACME; Company: EViL Corp. 序列号：D49Z5JJQ013QVW360H0N5VJ1BZ0A)</p><p>GiliSoft File Lock Pro 10.6.0  加密方式，未知。同样作为一款文件加密软件，具有防止文件锁，文件加密，文件夹加密，针对外部USB设备文件夹加密等功能。其中的文件锁功能，可以在当前系统环境下有效防止文件的复制，剪切，粘贴，或是重命名等修改操作，进而防止数据的外泄，该软件被广泛应用于商业机构。据官网称，GiliSoft File Lock Pro 10.7.0版本的防止文件复制功能甚至在安全模式下依旧有效。在更早期的版本中，本人发现了致命性的漏洞（据本人实测，在10.6.0版本中，进入安全模式，用户可任意对文件做出修改，该保护功能失效）。或许更为早期的版本，还无法突破安全模式非系统进程的限制，致使在该环境下文件保护形同虚设。虽然该软件毁誉参半，但与其他加密软件组合使用仍能发挥一定作用。</p><h6 id="三-：设置CMOS密码"><a href="#三-：设置CMOS密码" class="headerlink" title="三 ：设置CMOS密码"></a>三 ：设置CMOS密码</h6><p>该方式作为更底层的加密方式可有效防止外部存储设备对系统的修改，但不可避免的同样存在安全漏洞，他人可以通过电池放电的方法使其恢复出厂设置，尽管系统时间会初始化，但显而易见的，原密码将不复存在。他人只需将将主板上的CMOS电池取下3min即可完成放电。因此，该方法不建议台式计算机使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;
2013年6月，前美国中央情报局技术分析员，爱德华.斯诺登将美国“棱镜”电子监听计划披露给英国《卫报》记者格伦·格林沃尔德。如今，有越来越多的证据显示，个人电子邮件，浏览信息，聊天记录，网站信息正在被大规模的监控。从斯诺登曝光的机密文件可看出，NAS（美国国家安全局）不仅通过网络远程监控，还通过“人力情报”项目的方式挖取个人隐私。人们有必要去采取必要手段来抑制有关机构这种不正当的行径，从而维护公民基本合法权益。
&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="https://blog.kixcs.com/categories/network/"/>
    
    
      <category term="Windows" scheme="https://blog.kixcs.com/tags/Windows/"/>
    
  </entry>
  
</feed>
